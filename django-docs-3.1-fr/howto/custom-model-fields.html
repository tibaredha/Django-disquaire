
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Écriture de champs de modèles personnalisés &#8212; Documentation Django 3.1.3.dev</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="next" title="Expressions de recherche personnalisées" href="custom-lookups.html" />
    <link rel="prev" title="Écriture de commandes django-admin personnalisées" href="custom-management-commands.html" />



 
<script src="../templatebuiltins.js"></script>
<script>
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "../ref/templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);</script>

  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Documentation Django 3.1.3.dev</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">Home</a>  |
        <a title="Table of contents" href="../contents.html">Table of contents</a>  |
        <a title="Global index" href="../genindex.html">Index</a>  |
        <a title="Module index" href="../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="custom-management-commands.html" title="Écriture de commandes &lt;code class=&#34;docutils literal notranslate&#34;&gt;&lt;span class=&#34;pre&#34;&gt;django-admin&lt;/span&gt;&lt;/code&gt; personnalisées">previous</a>
     |
    <a href="index.html" title="Guides pratiques" accesskey="U">up</a>
   |
    <a href="custom-lookups.html" title="Expressions de recherche personnalisées">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="howto-custom-model-fields">
            
  <div class="section" id="s-writing-custom-model-fields">
<span id="writing-custom-model-fields"></span><h1>Écriture de champs de modèles personnalisés<a class="headerlink" href="#writing-custom-model-fields" title="Lien permanent vers ce titre">¶</a></h1>
<div class="section" id="s-introduction">
<span id="introduction"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Lien permanent vers ce titre">¶</a></h2>
<p>La documentation de <a class="reference internal" href="../topics/db/models.html"><span class="doc">référence sur les modèles</span></a> explique comment utiliser les classes de champs standard de Django&nbsp;: <a class="reference internal" href="../ref/models/fields.html#django.db.models.CharField" title="django.db.models.CharField"><code class="xref py py-class docutils literal notranslate"><span class="pre">CharField</span></code></a>, <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateField" title="django.db.models.DateField"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateField</span></code></a>, etc. Dans la plupart des cas, ces classes sont suffisantes. Cependant, il peut arriver que l’offre de Django ne réponde pas à toutes vos exigences, ou que vous vouliez utiliser un champ totalement différent de ceux mis à disposition par Django.</p>
<p>Les types de champs intégrés de Django ne gèrent pas tous les types possibles de colonnes de bases de données, mais seulement les plus courants comme <code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code> et <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code>. Pour des types de colonnes moins usités, comme les polygones géographiques ou même des types définis par les utilisateurs du style des <a class="reference external" href="https://www.postgresql.org/docs/current/sql-createtype.html">types PostgreSQL personnalisés</a>, vous pouvez définir vos propres sous-classes de <code class="docutils literal notranslate"><span class="pre">Field</span></code>.</p>
<p>D’un autre côté, vous pourriez avoir un objet Python complexe pouvant être sérialisé d’une manière ou d’une autre dans un type de colonne standard d’une base de données. C’est une autre situation où une sous-classe de  <code class="docutils literal notranslate"><span class="pre">Field</span></code> peut vous aider à utiliser cet objet avec vos modèles.</p>
<div class="section" id="s-our-example-object">
<span id="our-example-object"></span><h3>Notre exemple d’objet<a class="headerlink" href="#our-example-object" title="Lien permanent vers ce titre">¶</a></h3>
<p>La création de champs personnalisés exige un peu d’attention aux détails. Pour rendre les choses plus faciles à suivre, nous allons utiliser un même exemple tout au long de ce document&nbsp;: encapsuler un objet Python représentant une distribution de cartes dans une main de <a class="reference external" href="https://en.wikipedia.org/wiki/Contract_bridge">Bridge</a>. Ne vous inquiétez pas, il n’y a pas besoin de savoir jouer au Bridge pour suivre cet exemple. Il suffit de savoir que les 52 cartes sont distribuées équitablement entre quatre joueurs, traditionnellement appelés <em>nord</em>, <em>est</em>, <em>sud</em> et <em>ouest</em>. Notre classe ressemble à ceci&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Hand</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A hand of cards (bridge style)&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">north</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">west</span><span class="p">):</span>
        <span class="c1"># Input parameters are lists of cards (&#39;Ah&#39;, &#39;9s&#39;, etc.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">north</span> <span class="o">=</span> <span class="n">north</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">east</span> <span class="o">=</span> <span class="n">east</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">south</span> <span class="o">=</span> <span class="n">south</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">west</span> <span class="o">=</span> <span class="n">west</span>

    <span class="c1"># ... (other possibly useful methods omitted) ...</span>
</pre></div>
</div>
<p>C’est une classe Python ordinaire sans spécificité Django. Nous aimerions pouvoir faire des choses telles que celles-ci dans nos modèles (en supposant que l’attribut <code class="docutils literal notranslate"><span class="pre">hand</span></code> du modèle est une instance de <code class="docutils literal notranslate"><span class="pre">Hand</span></code>)&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">example</span> <span class="o">=</span> <span class="n">MyModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">example</span><span class="o">.</span><span class="n">hand</span><span class="o">.</span><span class="n">north</span><span class="p">)</span>

<span class="n">new_hand</span> <span class="o">=</span> <span class="n">Hand</span><span class="p">(</span><span class="n">north</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">west</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">hand</span> <span class="o">=</span> <span class="n">new_hand</span>
<span class="n">example</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>Nous écrivons et lisons dans l’attribut <code class="docutils literal notranslate"><span class="pre">hand</span></code> de notre modèle comme on le ferait avec tout autre classe Python. L’astuce est d’indiquer à Django comment enregistrer et charger un tel objet.</p>
<p>Pour pouvoir utiliser la classe <code class="docutils literal notranslate"><span class="pre">Hand</span></code> dans nos modèles, nous ne devons <strong>en aucune façon</strong> modifier cette classe. C’est idéal, car cela signifie qu’il est facilement possible d’implémenter la fonctionnalité «&nbsp;modèle&nbsp;» pour des classes existantes dont le code source n’est pas modifiable.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Il se peut que vous vouliez uniquement profiter de types personnalisés de colonnes de bases de données et gérer les données comment des types Python standards dans vos modèles&nbsp;; chaînes ou nombres à virgules, par exemple. Cette situation est semblable à notre exemple <code class="docutils literal notranslate"><span class="pre">Hand</span></code> et nous signalerons d’éventuelles différences quand elles apparaîtront.</p>
</div>
</div>
</div>
<div class="section" id="s-background-theory">
<span id="background-theory"></span><h2>Contexte théorique<a class="headerlink" href="#background-theory" title="Lien permanent vers ce titre">¶</a></h2>
<div class="section" id="s-database-storage">
<span id="database-storage"></span><h3>Stockage de base de données<a class="headerlink" href="#database-storage" title="Lien permanent vers ce titre">¶</a></h3>
<p>Commençons par les champs de modèles. Si on le décompose, un champ de modèle est un moyen de traiter un objet Python normal (une chaîne, une valeur booléenne, un <code class="docutils literal notranslate"><span class="pre">datetime</span></code> ou un objet plus complexe comme <code class="docutils literal notranslate"><span class="pre">Hand</span></code>) et de le convertir en un format adapté à l’utilisation avec une base de données (ce format convient également pour la sérialisation, mais nous verrons plus loin que cela se conçoit assez naturellement lorsque la partie base de données est maîtrisée).</p>
<p>D’une manière ou d’une autre, les champs d’un modèle doivent être transformés pour correspondre à un type de colonne d’une base de données. Des bases de données différentes fournissent différents choix de types de colonnes valables, mais la règle est toujours la même&nbsp;: ce sont ces types avec lesquels vous devez travailler. Tout ce que vous voulez stocker dans la base de données doit correspondre à l’un de ces types.</p>
<p>Normalement, soit vous écrivez un champ Django qui correspondra à un type particulier de colonne de base de données, soit il faut trouver une manière de convertir vos données, par exemple en une chaîne.</p>
<p>Pour notre exemple <code class="docutils literal notranslate"><span class="pre">Hand</span></code>, nous pourrions convertir les données des cartes en une chaîne de 104 caractères en concaténant toutes les cartes dans un ordre prédéterminé, par exemple d’abord toutes les cartes <em>nord</em>, puis toutes les cartes <em>est</em>, <em>sud</em> et <em>ouest</em>. Ainsi les objets <code class="docutils literal notranslate"><span class="pre">Hand</span></code> peuvent être enregistrés dans des colonnes texte ou caractères de la base de données.</p>
</div>
<div class="section" id="s-what-does-a-field-class-do">
<span id="what-does-a-field-class-do"></span><h3>Que fait une classe de champ&nbsp;?<a class="headerlink" href="#what-does-a-field-class-do" title="Lien permanent vers ce titre">¶</a></h3>
<p>Tous les champs Django (et lorsque nous parlons de <em>champs</em> dans ce document, nous parlons toujours de champs de modèles et non pas de <a class="reference internal" href="../ref/forms/fields.html"><span class="doc">champs de formulaires</span></a>) sont des sous-classes de <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.db.models.Field</span></code></a>. La plupart des informations que Django conserve sur un champ sont communs à tous les champs (nom, texte d’aide, unicité, etc.). Le stockage de toutes ces informations est géré par <code class="docutils literal notranslate"><span class="pre">Field</span></code>. Nous verrons plus précisément ce que peut faire <code class="docutils literal notranslate"><span class="pre">Field</span></code> un peu plus tard&nbsp;; pour l’instant, contentons-nous de savoir que tout hérite de <code class="docutils literal notranslate"><span class="pre">Field</span></code> et personnalise les éléments clés du comportement de la classe.</p>
<p>Il est important de réaliser qu’une classe de champ Django n’est pas ce qui est stocké dans les attributs de vos modèles. Les attributs des modèles contiennent des objets Python habituels. Les classes de champs que vous définissez dans un modèle sont en réalité stockés dans la classe <code class="docutils literal notranslate"><span class="pre">Meta</span></code> au moment de la création de la classe de modèle (il n’est pas important ici de connaître les détails précis de ce processus). Ceci est dû au fait que les classes de champs ne sont pas nécessaires tant qu’il s’agit simplement de créer et modifier des attributs. Par contre, elles fournissent les mécanismes de conversion entre les valeurs d’attributs et ce qui est effectivement stocké dans la base de données ou envoyé au <a class="reference internal" href="../topics/serialization.html"><span class="doc">sérialiseur</span></a>.</p>
<p>Gardez ceci à l’esprit lors de la création de vos propres champs personnalisés. La sous-classe <code class="docutils literal notranslate"><span class="pre">Field</span></code> Django que vous écrivez fournit les mécanismes de conversion entre vos instances Python et les valeurs de base de données ou de sérialisation de diverses manières (il existe par exemple des différences entre le stockage d’une valeur et son utilisation dans une requête). Si tout cela semble un peu compliqué, ne vous inquiétez pas, cela deviendra plus clair dans les exemples ci-dessous. Rappelez-vous seulement que vous allez souvent créer deux classes lorsque vous voulez créer un champ personnalisé&nbsp;:</p>
<ul class="simple">
<li>La première classe constitue l’objet Python que vos utilisateurs vont manipuler. Ils l’utiliseront comme attribut de modèle, ils liront ses valeurs à destination de l’affichage, et ainsi de suite. Il s’agit là de la classe <code class="docutils literal notranslate"><span class="pre">Hand</span></code> de notre exemple.</li>
<li>La seconde classe est la sous-classe de <code class="docutils literal notranslate"><span class="pre">Field</span></code>. C’est la classe qui sait comment convertir votre première classe de sa forme utile pour le stockage vers sa forme Python et vice versa.</li>
</ul>
</div>
</div>
<div class="section" id="s-writing-a-field-subclass">
<span id="writing-a-field-subclass"></span><h2>Écriture d’une sous-classe de champ<a class="headerlink" href="#writing-a-field-subclass" title="Lien permanent vers ce titre">¶</a></h2>
<p>Lors de la planification de votre sous-classe de <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>, réfléchissez d’abord à quelle classe <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> existante votre nouveau champ ressemble le plus. Serait-il possible d’hériter d’un champ Django existant et d’économiser un peu de travail&nbsp;? Si non, vous devrez hériter de la classe <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> qui est le parent de toutes les autres.</p>
<p>L’initialisation du nouveau champ consiste à séparer tout paramètre qui est spécifique à votre champ, des paramètres standards, et de transmettre ces derniers à la méthode <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> de <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> (ou d’une autre classe parente).</p>
<p>Dans notre exemple, nous appellerons notre champ <code class="docutils literal notranslate"><span class="pre">HandField</span></code> (il est conseillé d’appeler votre sous-classe de <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> sur le modèle <code class="docutils literal notranslate"><span class="pre">&lt;QuelqueChose&gt;Field</span></code> afin qu’on distingue rapidement qu’il s’agit d’une sous-classe de <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>). Notre champ ne ressemble à aucun autre champ existant, nous allons donc hériter directement de <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.db</span> <span class="k">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>

    <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;A hand of cards (bridge style)&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;max_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">104</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>Le champ <code class="docutils literal notranslate"><span class="pre">HandField</span></code> accepte la plupart des options standards de champs (voir liste ci-dessous), mais nous voulons nous assurer que sa longueur soit fixe, étant donné qu’il ne doit stocker que les valeurs de 52 cartes plus leur couleur&nbsp;; 104 caractères au total.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Beaucoup de champs de modèles Django acceptent des options qui ne sont pas exploitées. Par exemple, vous pouvez passer à la fois <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.editable" title="django.db.models.Field.editable"><code class="xref py py-attr docutils literal notranslate"><span class="pre">editable</span></code></a> et <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><code class="xref py py-attr docutils literal notranslate"><span class="pre">auto_now</span></code></a> à <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateField" title="django.db.models.DateField"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.db.models.DateField</span></code></a> et il ignorera le paramètre <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.editable" title="django.db.models.Field.editable"><code class="xref py py-attr docutils literal notranslate"><span class="pre">editable</span></code></a> (la définition d”<a class="reference internal" href="../ref/models/fields.html#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><code class="xref py py-attr docutils literal notranslate"><span class="pre">auto_now</span></code></a> implique que``editable=False``). Aucune erreur ne survient dans ce cas.</p>
<p class="last">Ce comportement simplifie les classes de champs, car elles n’ont pas besoin de vérifier les options qui ne sont pas nécessaires. Elles transmettent toutes les options à la classe parente et ne les utilisent plus. Il ne tient qu’à vous d’être plus strict sur les options acceptées, ou d’adopter le comportement plus permissif des champs actuels.</p>
</div>
<p>La méthode <code class="docutils literal notranslate"><span class="pre">Field.__init__()</span></code> accepte les paramètres suivants&nbsp;:</p>
<ul class="simple">
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.verbose_name" title="django.db.models.Field.verbose_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verbose_name</span></code></a></li>
<li><code class="docutils literal notranslate"><span class="pre">name</span></code></li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.primary_key" title="django.db.models.Field.primary_key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">primary_key</span></code></a></li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.CharField.max_length" title="django.db.models.CharField.max_length"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_length</span></code></a></li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.unique" title="django.db.models.Field.unique"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unique</span></code></a></li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.blank" title="django.db.models.Field.blank"><code class="xref py py-attr docutils literal notranslate"><span class="pre">blank</span></code></a></li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.null" title="django.db.models.Field.null"><code class="xref py py-attr docutils literal notranslate"><span class="pre">null</span></code></a></li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_index" title="django.db.models.Field.db_index"><code class="xref py py-attr docutils literal notranslate"><span class="pre">db_index</span></code></a></li>
<li><code class="docutils literal notranslate"><span class="pre">rel</span></code>: utilisé pour les champs de liaison (comme <a class="reference internal" href="../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>). Uniquement pour une utilisation avancée.</li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.default" title="django.db.models.Field.default"><code class="xref py py-attr docutils literal notranslate"><span class="pre">default</span></code></a></li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.editable" title="django.db.models.Field.editable"><code class="xref py py-attr docutils literal notranslate"><span class="pre">editable</span></code></a></li>
<li><code class="docutils literal notranslate"><span class="pre">serialize</span></code>: si <code class="docutils literal notranslate"><span class="pre">False</span></code>, le champ ne sera pas sérialisé lorsque le modèle est transmis aux <a class="reference internal" href="../topics/serialization.html"><span class="doc">sérialiseurs</span></a> de Django. La valeur par défaut est <code class="docutils literal notranslate"><span class="pre">True</span></code>.</li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.unique_for_date" title="django.db.models.Field.unique_for_date"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unique_for_date</span></code></a></li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.unique_for_month" title="django.db.models.Field.unique_for_month"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unique_for_month</span></code></a></li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.unique_for_year" title="django.db.models.Field.unique_for_year"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unique_for_year</span></code></a></li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.choices" title="django.db.models.Field.choices"><code class="xref py py-attr docutils literal notranslate"><span class="pre">choices</span></code></a></li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.help_text" title="django.db.models.Field.help_text"><code class="xref py py-attr docutils literal notranslate"><span class="pre">help_text</span></code></a></li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_column" title="django.db.models.Field.db_column"><code class="xref py py-attr docutils literal notranslate"><span class="pre">db_column</span></code></a></li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_tablespace" title="django.db.models.Field.db_tablespace"><code class="xref py py-attr docutils literal notranslate"><span class="pre">db_tablespace</span></code></a>&nbsp;: seulement pour la création d’index, pour autant que le moteur gère les <a class="reference internal" href="../topics/db/tablespaces.html"><span class="doc">espaces de tables</span></a>. Vous pouvez généralement ignorer cette option.</li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.auto_created" title="django.db.models.Field.auto_created"><code class="xref py py-attr docutils literal notranslate"><span class="pre">auto_created</span></code></a>: vaut <code class="docutils literal notranslate"><span class="pre">True</span></code> si le champ a été créé automatiquement, comme pour le champ <a class="reference internal" href="../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> utilisé dans un contexte d’héritage de modèles. Pour utilisation avancée uniquement.</li>
</ul>
<p>Toutes les options sans explications dans la liste ci-dessus ont la même signification que pour les champs Django normaux. Consultez la  <a class="reference internal" href="../ref/models/fields.html"><span class="doc">documentation sur les champs</span></a> pour des exemples et des détails.</p>
<div class="section" id="s-field-deconstruction">
<span id="s-custom-field-deconstruct-method"></span><span id="field-deconstruction"></span><span id="custom-field-deconstruct-method"></span><h3>Déconstruction de champ<a class="headerlink" href="#field-deconstruction" title="Lien permanent vers ce titre">¶</a></h3>
<p>La contrepartie à l’écriture de la méthode <code class="docutils literal notranslate"><span class="pre">__init</span> <span class="pre">__()</span></code> est l’écriture de la méthode <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.deconstruct" title="django.db.models.Field.deconstruct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">deconstruct()</span></code></a>. Celle-ci est utilisée durant les <a href="#id1"><span class="problematic" id="id2">:docs:`migrations de modèles &lt;/topics/migrations&gt;`</span></a> pour indiquer à Django comment prendre une instance du nouveau champ afin de le réduire en format sérialisé&nbsp;; en particulier, le choix des paramètres à passer à <code class="docutils literal notranslate"><span class="pre">__init</span> <span class="pre">__()</span></code> pour le recréer.</p>
<p>Si vous n’avez pas ajouté d’options supplémentaires au champ dont vous avez hérité, il n’y a alors pas besoin d’écrire une nouvelle méthode <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code>. Si toutefois vous modifiez les paramètres passés à <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> (comme nous l’avons fait avec <code class="docutils literal notranslate"><span class="pre">HandField</span></code>), il sera nécessaire de compléter les valeurs transmises.</p>
<p><code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> renvoie un tuple de quatre éléments&nbsp;: le nom d’attribut du champ, le chemin d’importation complet de la classe du champ, les paramètres positionnels (sous forme de liste), et les paramètres nommés (sous forme de dictionnaire). Notez la différence avec la méthode <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> des <a class="reference internal" href="../topics/migrations.html#custom-deconstruct-method"><span class="std std-ref">classes personnalisées</span></a> qui renvoie un tuple de trois éléments.</p>
<p>En tant qu’auteur de champ personnalisé, vous n’avez pas besoin de vous soucier des deux premières valeurs&nbsp;; la classe de base <code class="docutils literal notranslate"><span class="pre">Field</span></code> contient tout le code pour déterminer le nom d’attribut et le chemin d’importation du champ. Vous devez cependant vous préoccuper des paramètres positionnels et nommés, puisque ceux-ci font généralement partie des éléments que vous modifiez.</p>
<p>Par exemple, dans notre classe <code class="docutils literal notranslate"><span class="pre">HandField</span></code>, nous forçons toujours l’utilisation de <code class="docutils literal notranslate"><span class="pre">max_length</span></code> dans <code class="docutils literal notranslate"><span class="pre">__init__()</span></code>. La méthode <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> de la classe de base <code class="docutils literal notranslate"><span class="pre">Field</span></code> le verra et essayera de le renvoyer dans les paramètres nommés&nbsp;; ainsi, nous pouvons le supprimer des paramètres nommés pour une meilleure lisibilité&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.db</span> <span class="k">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;max_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">104</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deconstruct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">deconstruct</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;max_length&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>
</pre></div>
</div>
<p>Si vous ajoutez un nouveau paramètre nommé, vous devez écrire vous-même du code dans <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> qui place sa valeur dans <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>. Vous devriez aussi omettre la valeur de <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> lorsqu’il n’est pas nécessaire de reconstruire l’état du champ, comme par exemple lorsque la valeur par défaut est utilisée</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.db</span> <span class="k">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">CommaSepField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="s2">&quot;Implements comma-separated storage of lists&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separator</span> <span class="o">=</span> <span class="n">separator</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deconstruct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">deconstruct</span><span class="p">()</span>
        <span class="c1"># Only include kwarg if it&#39;s not the default</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separator</span> <span class="o">!=</span> <span class="s2">&quot;,&quot;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;separator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">separator</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>
</pre></div>
</div>
<p>Des exemples plus complexes sont au-delà de la portée de ce document, mais rappelez-vous – pour toute configuration de votre instance de champ, <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> doit renvoyer les paramètres que vous pouvez passer à <code class="docutils literal notranslate"><span class="pre">__init__</span></code> afin de reconstruire cet état.</p>
<p>Portez une attention toute particulière si vous définissez de nouvelles valeurs par défaut pour les paramètres de la classe parente <code class="docutils literal notranslate"><span class="pre">Field</span></code>; vous devez vous assurer qu’elles sont toujours incluses, sinon elles pourraient disparaître si elles prennent les anciennes valeurs par défaut.</p>
<p>En outre, essayez d’éviter de renvoyer les valeurs en tant que paramètres positionnels&nbsp;; autant que possible, renvoyez les valeurs en tant que paramètres nommés pour une compatibilité future maximale. Si vous changez plutôt le nom que la position des éléments dans la liste des paramètres du constructeur, les paramètres positionnels sont préférables, mais gardez à l’esprit que les gens reconstruiront votre champ à partir de la version sérialisée pendant un certain temps (voire des années), selon la durée de vie de vos migrations.</p>
<p>Vous pouvez voir les résultats de la déconstruction en regardant les migrations qui incluent ledit champ, et vous pouvez tester la déconstruction dans les tests unitaires en déconstruisant et reconstruisant le champ&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">my_field_instance</span><span class="o">.</span><span class="n">deconstruct</span><span class="p">()</span>
<span class="n">new_instance</span> <span class="o">=</span> <span class="n">MyField</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">my_field_instance</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="n">new_instance</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-changing-a-custom-field-s-base-class">
<span id="changing-a-custom-field-s-base-class"></span><h3>Modification de la classe de base d’un champ personnalisé<a class="headerlink" href="#changing-a-custom-field-s-base-class" title="Lien permanent vers ce titre">¶</a></h3>
<p>Il n’est pas possible de modifier la classe de base d’un champ personnalisé, car Django ne détectera pas le changement et ne créera pas de migration. Par exemple, si vous commencez avec&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomCharField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>puis que vous décidez de vous baser plutôt sur <code class="docutils literal notranslate"><span class="pre">TextField</span></code>, vous ne pouvez pas simplement modifier la sous-classe comme ceci&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomCharField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Vous devez plutôt créer une nouvelle classe de champ personnalisé et mettre à jour vos modèles pour référencer cette nouvelle classe&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomCharField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">class</span> <span class="nc">CustomTextField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Comme discuté dans <a class="reference internal" href="../topics/migrations.html#migrations-removing-model-fields"><span class="std std-ref">suppression de champs</span></a>, vous devez conserver la classe <code class="docutils literal notranslate"><span class="pre">CustomCharField</span></code> originale tant que vous conservez des migrations qui la référencent.</p>
</div>
<div class="section" id="s-documenting-your-custom-field">
<span id="documenting-your-custom-field"></span><h3>Documentation du champ personnalisé<a class="headerlink" href="#documenting-your-custom-field" title="Lien permanent vers ce titre">¶</a></h3>
<p>Comme toujours, il est souhaitable de documenter votre type de champ, afin que les utilisateurs sachent de quoi il s’agit. En plus de lui fournir une chaîne «&nbsp;docstring&nbsp;» utile pour les développeurs, vous pouvez également permettre aux utilisateurs de l’application d’administration de voir une courte description du type de champ via l’application <a class="reference internal" href="../ref/contrib/admin/admindocs.html"><span class="doc">django.contrib.admindocs</span></a>. Pour ce faire, fournissez un texte descriptif dans l’attribut de classe <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.description" title="django.db.models.Field.description"><code class="xref py py-attr docutils literal notranslate"><span class="pre">description</span></code></a> du champ personnalisé. Dans l’exemple ci-dessus, la description affichée par l’application <code class="docutils literal notranslate"><span class="pre">admindocs</span></code> pour un <code class="docutils literal notranslate"><span class="pre">HandField</span></code> sera «&nbsp;A hand of cards (bridge style)&nbsp;».</p>
<p>Dans l’affichage <a class="reference internal" href="../ref/contrib/admin/admindocs.html#module-django.contrib.admindocs" title="django.contrib.admindocs: Django's admin documentation generator."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.admindocs</span></code></a>, la description du champ est interpolée avec <code class="docutils literal notranslate"><span class="pre">field.__dict__</span></code>, ce qui permet à la description de contenir des paramètres du champ. Par exemple, la description de <a class="reference internal" href="../ref/models/fields.html#django.db.models.CharField" title="django.db.models.CharField"><code class="xref py py-class docutils literal notranslate"><span class="pre">CharField</span></code></a> est&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">description</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;String (up to </span><span class="si">%(max_length)s</span><span class="s2">)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-useful-methods">
<span id="useful-methods"></span><h3>Méthodes utiles<a class="headerlink" href="#useful-methods" title="Lien permanent vers ce titre">¶</a></h3>
<p>Après avoir créé la sous-classe de <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>, il peut être utile de surcharger quelques méthodes standards, en fonction du comportement du champ. La liste de méthodes ci-dessous est plus ou moins dans l’ordre décroissant d’importance, il faut donc commencer par les premières.</p>
<div class="section" id="s-custom-database-types">
<span id="s-id1"></span><span id="custom-database-types"></span><span id="id1"></span><h4>Types de base de données personnalisés<a class="headerlink" href="#custom-database-types" title="Lien permanent vers ce titre">¶</a></h4>
<p>Disons que vous avez créé un type personnalisé PostgreSQL appelé <code class="docutils literal notranslate"><span class="pre">mytype</span></code>. Vous pouvez dériver <code class="docutils literal notranslate"><span class="pre">Field</span></code> et implémenter la méthode <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a>, comme suit&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.db</span> <span class="k">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">MytypeField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;mytype&#39;</span>
</pre></div>
</div>
<p>Après avoir créé <code class="docutils literal notranslate"><span class="pre">MytypeField</span></code>, il est possible de l’utiliser dans n’importe quel modèle, comme pour tout autre type <code class="docutils literal notranslate"><span class="pre">Field</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
    <span class="n">something_else</span> <span class="o">=</span> <span class="n">MytypeField</span><span class="p">()</span>
</pre></div>
</div>
<p>Si votre objectif est de créer une application indépendante du choix de la base de données, vous devriez tenir compte des différences de types de colonne de base de données. Par exemple, le type de colonne date/heure dans PostgreSQL est appelé <code class="docutils literal notranslate"><span class="pre">timestamp</span></code> alors que la même colonne dans MySQL est appelée <code class="docutils literal notranslate"><span class="pre">datetime</span></code>. Vous pouvez gérer cela dans une méthode <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a> en vous basant sur l’attribut <code class="docutils literal notranslate"><span class="pre">connection.settings_dict['ENGINE']</span></code>.</p>
<p>Par exemple&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyDateField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">connection</span><span class="o">.</span><span class="n">settings_dict</span><span class="p">[</span><span class="s1">&#39;ENGINE&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;django.db.backends.mysql&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;datetime&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;timestamp&#39;</span>
</pre></div>
</div>
<p>Les méthodes <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a> et <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.rel_db_type" title="django.db.models.Field.rel_db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rel_db_type()</span></code></a> sont appelées par Django lorsque le système construit les instructions <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> pour votre application – c’est-à-dire lors de la création initiale des tables. Elles sont aussi appelées lors de la construction d’une clause <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> qui comprend le champ de modèle – c’est-à-dire lorsque vous récupérez des données à l’aide de méthodes de QuerySet telles que <code class="docutils literal notranslate"><span class="pre">get()</span></code>, <code class="docutils literal notranslate"><span class="pre">filter()</span></code> ou <code class="docutils literal notranslate"><span class="pre">exclude()</span></code> et que le champ de modèle se trouve en paramètre. Elles ne sont appelées à aucun autre moment, elles peuvent donc se permettre d’exécuter du code un peu complexe, comme la vérification de <code class="docutils literal notranslate"><span class="pre">connection.settings_dict</span></code> dans l’exemple ci-dessus.</p>
<p>Certains types de colonnes de base de données acceptent des paramètres tels que <code class="docutils literal notranslate"><span class="pre">CHAR(25)</span></code>, où le paramètre <code class="docutils literal notranslate"><span class="pre">25</span></code> représente la taille maximale de la colonne. Dans de tels cas, il est plus souple de définir le paramètre dans le modèle plutôt qu’il soit codé en dur dans la méthode <code class="docutils literal notranslate"><span class="pre">db_type()</span></code>. Par exemple, ce ne serait pas très raisonnable d’avoir un type <code class="docutils literal notranslate"><span class="pre">CharMaxlength25Field</span></code> tel que ci-dessous&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># This is a silly example of hard-coded parameters.</span>
<span class="k">class</span> <span class="nc">CharMaxlength25Field</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;char(25)&#39;</span>

<span class="c1"># In the model:</span>
<span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="n">my_field</span> <span class="o">=</span> <span class="n">CharMaxlength25Field</span><span class="p">()</span>
</pre></div>
</div>
<p>La meilleure manière de résoudre ce problème serait d’autoriser le paramètre à être défini au moment de l’exécution, c’est-à-dire quand la classe est instanciée. Pour faire cela, implémentez la méthode <code class="docutils literal notranslate"><span class="pre">Field.__init__()</span></code> comme ceci&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># This is a much more flexible example.</span>
<span class="k">class</span> <span class="nc">BetterCharField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_length</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">max_length</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;char(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span>

<span class="c1"># In the model:</span>
<span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="n">my_field</span> <span class="o">=</span> <span class="n">BetterCharField</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
</pre></div>
</div>
<p>Pour terminer, si votre colonne exige une configuration SQL vraiment complexe, renvoyez <code class="docutils literal notranslate"><span class="pre">None</span></code> depuis <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a>. Cela aura pour conséquence que le code de création SQL de Django va omettre ce champ. Vous êtes alors responsable de créer la colonne dans la bonne table d’une autre manière, mais au moins cela vous permet d’indiquer à Django de ne pas intervenir dans ce processus.</p>
<p>La méthode <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.rel_db_type" title="django.db.models.Field.rel_db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rel_db_type()</span></code></a> est appelée par des champs tels que <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> et <code class="docutils literal notranslate"><span class="pre">OneToOneField</span></code> qui pointent vers un autre champ pour déterminer leur type de colonne de base de données. Par exemple, si vous avez un <code class="docutils literal notranslate"><span class="pre">UnsignedAutoField</span></code>, vous avez aussi besoin que les clés étrangères qui pointent vers ce champ utilisent le même type de données&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># MySQL unsigned integer (range 0 to 4294967295).</span>
<span class="k">class</span> <span class="nc">UnsignedAutoField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">AutoField</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;integer UNSIGNED AUTO_INCREMENT&#39;</span>

    <span class="k">def</span> <span class="nf">rel_db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;integer UNSIGNED&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="s-converting-values-to-python-objects">
<span id="s-id2"></span><span id="converting-values-to-python-objects"></span><span id="id2"></span><h4>Conversion de valeurs en objets Python<a class="headerlink" href="#converting-values-to-python-objects" title="Lien permanent vers ce titre">¶</a></h4>
<p>Si votre classe <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> personnalisée manipule des structures de données plus complexes que des chaînes, des dates, des entiers ou des nombres à virgule, il peut être nécessaire de surcharger <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.from_db_value" title="django.db.models.Field.from_db_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_db_value()</span></code></a> et <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.to_python" title="django.db.models.Field.to_python"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_python()</span></code></a>.</p>
<p>Si elle est présente dans la sous-classe de champ, <code class="docutils literal notranslate"><span class="pre">from_db_value()</span></code> sera appelée dans tous les cas où des données sont chargées à partir de la base de données, y compris dans les appels d’agrégation et les appels <a class="reference internal" href="../ref/models/querysets.html#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">to_python()</span></code> est appelée par la désérialisation et dans le cadre de la méthode  <a class="reference internal" href="../ref/models/instances.html#django.db.models.Model.clean" title="django.db.models.Model.clean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clean()</span></code></a> utilisée depuis les formulaires.</p>
<p>En règle générale, <code class="docutils literal notranslate"><span class="pre">to_python()</span></code> devrait gérer de manière élégante tous les paramètres suivants&nbsp;:</p>
<ul class="simple">
<li>Une instance ayant le type correct (par exemple <code class="docutils literal notranslate"><span class="pre">Hand</span></code> dans le cas modèle de ce document).</li>
<li>Une chaîne</li>
<li><code class="docutils literal notranslate"><span class="pre">None</span></code> (si le champ autorise <code class="docutils literal notranslate"><span class="pre">null=True</span></code>)</li>
</ul>
<p>Dans notre classe <code class="docutils literal notranslate"><span class="pre">HandField</span></code>, nous stockons les données avec un champ VARCHAR dans la base de données, il faut donc pouvoir gérer des chaînes de caractères et la valeur <code class="docutils literal notranslate"><span class="pre">None</span></code> dans <code class="docutils literal notranslate"><span class="pre">from_db_value()</span></code>. Dans``to_python()``, il est aussi nécessaire de gérer les instances de <code class="docutils literal notranslate"><span class="pre">Hand</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="kn">from</span> <span class="nn">django.core.exceptions</span> <span class="k">import</span> <span class="n">ValidationError</span>
<span class="kn">from</span> <span class="nn">django.db</span> <span class="k">import</span> <span class="n">models</span>
<span class="kn">from</span> <span class="nn">django.utils.translation</span> <span class="k">import</span> <span class="n">gettext_lazy</span> <span class="k">as</span> <span class="n">_</span>

<span class="k">def</span> <span class="nf">parse_hand</span><span class="p">(</span><span class="n">hand_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a string of cards and splits into a full hand.&quot;&quot;&quot;</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;.</span><span class="si">{26}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;..&#39;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">p2</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p1</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">hand_string</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s2">&quot;Invalid input for a Hand instance&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Hand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span> <span class="nf">from_db_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">parse_hand</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Hand</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">parse_hand</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>Remarquez que ces méthodes renvoient toujours une instance <code class="docutils literal notranslate"><span class="pre">Hand</span></code>. C’est le type d’objet Python que nous voulons stocker dans l’attribut du modèle.</p>
<p>Pour <code class="docutils literal notranslate"><span class="pre">to_python()</span></code>, si quoi que ce soit se passe mal durant la conversion de la valeur, il faut lever une exception de type <a class="reference internal" href="../ref/exceptions.html#django.core.exceptions.ValidationError" title="django.core.exceptions.ValidationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValidationError</span></code></a>.</p>
</div>
<div class="section" id="s-converting-python-objects-to-query-values">
<span id="s-id3"></span><span id="converting-python-objects-to-query-values"></span><span id="id3"></span><h4>Conversion d’objets Python en valeurs de requête<a class="headerlink" href="#converting-python-objects-to-query-values" title="Lien permanent vers ce titre">¶</a></h4>
<p>Comme l’utilisation d’une base de données nécessite une conversion dans les deux sens, si vous surchargez <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.from_db_value" title="django.db.models.Field.from_db_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_db_value()</span></code></a> vous devrez aussi surcharger <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_prep_value" title="django.db.models.Field.get_prep_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_prep_value()</span></code></a> pour convertir les objets Python vers des valeurs de requête.</p>
<p>Par exemple&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span> <span class="nf">get_prep_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">north</span><span class="p">,</span>
                <span class="n">value</span><span class="o">.</span><span class="n">east</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">south</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">west</span><span class="p">)])</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Avertissement</p>
<p class="last">Si votre champ personnalisé utilise les types <code class="docutils literal notranslate"><span class="pre">CHAR</span></code>, <code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code> ou <code class="docutils literal notranslate"><span class="pre">TEXT</span></code> de MySQL, vous devez garantir que la méthode <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_prep_value" title="django.db.models.Field.get_prep_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_prep_value()</span></code></a> renvoie toujours un type chaîne. MySQL effectue des correspondances souples mais imprévisibles lorsque des requêtes sur ces types se font avec un nombre entier, ce qui peut faire que les résultats contiendront des objets non prévus. Ce problème ne peut pas se produire si vous renvoyez systématiquement des chaînes dans <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_prep_value" title="django.db.models.Field.get_prep_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_prep_value()</span></code></a>.</p>
</div>
</div>
<div class="section" id="s-converting-query-values-to-database-values">
<span id="s-id4"></span><span id="converting-query-values-to-database-values"></span><span id="id4"></span><h4>Conversion de valeurs de requête en valeurs de base de données<a class="headerlink" href="#converting-query-values-to-database-values" title="Lien permanent vers ce titre">¶</a></h4>
<p>Certains types de données (par exemple les dates) doivent être dans un format spécifique avant de pouvoir être utilisées par un moteur de base de données. <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_db_prep_value" title="django.db.models.Field.get_db_prep_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_db_prep_value()</span></code></a> est la méthode où ces conversions doivent être réalisées. La connexion spécifique qui sera utilisée pour la requête est transmise en tant que paramètre <code class="docutils literal notranslate"><span class="pre">connection</span></code>. Cela vous permet d’utiliser la logique de conversion spécifique au moteur si cela est nécessaire.</p>
<p>Par exemple, Django utilise la méthode suivante pour son champ <a class="reference internal" href="../ref/models/fields.html#django.db.models.BinaryField" title="django.db.models.BinaryField"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryField</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_db_prep_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">prepared</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_db_prep_value</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">prepared</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">connection</span><span class="o">.</span><span class="n">Database</span><span class="o">.</span><span class="n">Binary</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>
</pre></div>
</div>
<p>Dans le cas où votre champ personnalisé a besoin d’une conversion spéciale lors de son enregistrement qui n’est pas la même que la conversion utilisée pour les paramètres normaux dans une requête, vous pouvez surcharger <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_db_prep_save" title="django.db.models.Field.get_db_prep_save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_db_prep_save()</span></code></a>.</p>
</div>
<div class="section" id="s-preprocessing-values-before-saving">
<span id="s-id5"></span><span id="preprocessing-values-before-saving"></span><span id="id5"></span><h4>Pré-traitement des valeurs avant enregistrement<a class="headerlink" href="#preprocessing-values-before-saving" title="Lien permanent vers ce titre">¶</a></h4>
<p>Si vous souhaitez pré-traiter la valeur juste avant l’enregistrement, vous pouvez utiliser <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.pre_save" title="django.db.models.Field.pre_save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pre_save()</span></code></a>. Par exemple, le champ <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateTimeField" title="django.db.models.DateTimeField"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTimeField</span></code></a> de Django utilise cette méthode pour définir correctement l’attribut dans le cas de <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><code class="xref py py-attr docutils literal notranslate"><span class="pre">auto_now</span></code></a> ou <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateField.auto_now_add" title="django.db.models.DateField.auto_now_add"><code class="xref py py-attr docutils literal notranslate"><span class="pre">auto_now_add</span></code></a>.</p>
<p>Si vous surchargez cette méthode, vous devez renvoyez la valeur de l’attribut à la fin. Vous devriez aussi mettre à jour l’attribut du modèle si vous modifiez la valeur, afin que tout code ayant des références sur le modèle voie toujours la valeur correcte.</p>
</div>
<div class="section" id="s-specifying-the-form-field-for-a-model-field">
<span id="s-specifying-form-field-for-model-field"></span><span id="specifying-the-form-field-for-a-model-field"></span><span id="specifying-form-field-for-model-field"></span><h4>Sélection du champ de formulaire pour un champ de modèle<a class="headerlink" href="#specifying-the-form-field-for-a-model-field" title="Lien permanent vers ce titre">¶</a></h4>
<p>Pour personnaliser le champ de formulaire utilisé par <a class="reference internal" href="../topics/forms/modelforms.html#django.forms.ModelForm" title="django.forms.ModelForm"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModelForm</span></code></a>, vous pouvez surcharger <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.formfield" title="django.db.models.Field.formfield"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formfield()</span></code></a>.</p>
<p>La classe de champ de formulaire peut être indiquée via les paramètres <code class="docutils literal notranslate"><span class="pre">form_class</span></code> et <code class="docutils literal notranslate"><span class="pre">choices_form_class</span></code>&nbsp;; ce dernier est utilisé si le champ contient une liste de choix, sinon c’est <code class="docutils literal notranslate"><span class="pre">form_class</span></code> qui est pris en compte. Si ces paramètres ne sont pas présents, c’est <a class="reference internal" href="../ref/forms/fields.html#django.forms.CharField" title="django.forms.CharField"><code class="xref py py-class docutils literal notranslate"><span class="pre">CharField</span></code></a> ou <a class="reference internal" href="../ref/forms/fields.html#django.forms.TypedChoiceField" title="django.forms.TypedChoiceField"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedChoiceField</span></code></a> qui seront utilisés.</p>
<p>Tout le contenu du dictionnaire <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> est directement transmis à la méthode <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> du champ de formulaire. En principe, tout ce qu’il y a à faire est de définir une bonne valeur par défaut du paramètre <code class="docutils literal notranslate"><span class="pre">form_class</span></code> (ou <code class="docutils literal notranslate"><span class="pre">choices_form_class</span></code>) puis de déléguer le reste à la classe parente. Il est possible que vous deviez écrire un champ de formulaire personnalisé (et même un composant de formulaire). Consultez la <a class="reference internal" href="../topics/forms/index.html"><span class="doc">documentation sur les formulaires</span></a> pour plus de détails sur ce sujet.</p>
<p>Poursuivant notre exemple en cours, on peut écrire la méthode <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.formfield" title="django.db.models.Field.formfield"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formfield()</span></code></a> ainsi&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span> <span class="nf">formfield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># This is a fairly standard way to set up some defaults</span>
        <span class="c1"># while letting the caller override them.</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;form_class&#39;</span><span class="p">:</span> <span class="n">MyFormField</span><span class="p">}</span>
        <span class="n">defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">formfield</span><span class="p">(</span><span class="o">**</span><span class="n">defaults</span><span class="p">)</span>
</pre></div>
</div>
<p>Nous partons du principe que la classe de champ <code class="docutils literal notranslate"><span class="pre">MyFormField</span></code> a été importée (elle possède son propre composant par défaut). Ce document ne traite pas en détails de l’écriture de champs de formulaires personnalisés.</p>
</div>
<div class="section" id="s-emulating-built-in-field-types">
<span id="s-id6"></span><span id="emulating-built-in-field-types"></span><span id="id6"></span><h4>Émulation de types de champs intégrés<a class="headerlink" href="#emulating-built-in-field-types" title="Lien permanent vers ce titre">¶</a></h4>
<p>Si vous avez créé une méthode <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a>, pas besoin de vous préoccuper de <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_internal_type" title="django.db.models.Field.get_internal_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_internal_type()</span></code></a>, elle ne sera que peu utilisée. Il peut cependant arriver que le stockage de votre base de données a un même type qu’un autre champ, vous pouvez donc réutiliser la logique de ce dernier pour créer la bonne colonne.</p>
<p>Par exemple&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span> <span class="nf">get_internal_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;CharField&#39;</span>
</pre></div>
</div>
<p>Quel que soit le moteur de base de données utilisé, cela signifie que <a class="reference internal" href="../ref/django-admin.html#django-admin-migrate"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">migrate</span></code></a> et les autres commandes SQL créeront le bon type de colonne pour le stockage d’une chaîne.</p>
<p>Si <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_internal_type" title="django.db.models.Field.get_internal_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_internal_type()</span></code></a> renvoie une chaîne qui n’est pas connu de Django pour le moteur de base de données que vous utilisez – autrement dit, qu’il n’apparaît pas dans <code class="docutils literal notranslate"><span class="pre">django.db.backends.&lt;db_name&gt;.base.DatabaseWrapper.data_types</span></code> – la chaîne sera quand même utilisée par le sérialiseur, mais la méthode par défaut <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a> retournera <code class="docutils literal notranslate"><span class="pre">None</span></code>. Consultez la documentation de <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a> pour les raisons pour lesquelles cela pourrait être utile. Mettre une chaîne descriptive dans le type du champ pour la sérialisation est une idée utile si vous devez un jour utiliser la sortie de sérialisation à un autre endroit, en dehors de Django.</p>
</div>
<div class="section" id="s-converting-field-data-for-serialization">
<span id="s-converting-model-field-to-serialization"></span><span id="converting-field-data-for-serialization"></span><span id="converting-model-field-to-serialization"></span><h4>Conversion des données de champs pour la sérialisation<a class="headerlink" href="#converting-field-data-for-serialization" title="Lien permanent vers ce titre">¶</a></h4>
<p>Pour personnaliser la façon dont les valeurs sont sérialisés par un sérialiseur, vous pouvez surcharger <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.value_to_string" title="django.db.models.Field.value_to_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">value_to_string()</span></code></a>. L’appel à <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.value_from_object" title="django.db.models.Field.value_from_object"><code class="xref py py-meth docutils literal notranslate"><span class="pre">value_from_object()</span></code></a> est le meilleur moyen d’obtenir la valeur du champ avant sa sérialisation. Par exemple, comme par ailleurs le champ <code class="docutils literal notranslate"><span class="pre">HandField</span></code> utilise des chaînes pour le stockage de ses données, nous pouvons réutiliser du code existant de conversion&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span> <span class="nf">value_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_from_object</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prep_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-some-general-advice">
<span id="some-general-advice"></span><h3>Quelques conseils généraux<a class="headerlink" href="#some-general-advice" title="Lien permanent vers ce titre">¶</a></h3>
<p>L’écriture d’un champ personnalisé peut être un processus fastidieux, particulièrement si vous procédez à des conversions complexes entre vos types Python et les formats de base de données et de sérialisation. Voici quelques astuces qui faciliteront ces opérations&nbsp;:</p>
<ol class="arabic simple">
<li>Observez les champs Django existants (dans <code class="file docutils literal notranslate"><span class="pre">django/db/models/fields/__init__.py</span></code>) comme source d’inspiration. Cherchez un champ qui ressemble à ce que vous voulez faire et complétez ce qui manque, au lieu de créer un tout nouveau champ à partir de zéro.</li>
<li>Écrivez une méthode <code class="docutils literal notranslate"><span class="pre">__str__()</span></code> pour la classe de champ que vous rédigez. À beaucoup d’endroits, le comportement par défaut du code du champ est d’appeler <code class="docutils literal notranslate"><span class="pre">str()</span></code> sur la valeur (dans les exemples de ce document, <code class="docutils literal notranslate"><span class="pre">value</span></code> serait une instance <code class="docutils literal notranslate"><span class="pre">Hand</span></code>, pas <code class="docutils literal notranslate"><span class="pre">HandField</span></code>). Ainsi, si votre méthode <code class="docutils literal notranslate"><span class="pre">__str__()</span></code> convertit automatiquement l’objet Python sous sa forme textuelle, vous économiserez beaucoup de travail.</li>
</ol>
</div>
</div>
<div class="section" id="s-writing-a-filefield-subclass">
<span id="writing-a-filefield-subclass"></span><h2>Écriture d’une sous-classe<a class="headerlink" href="#writing-a-filefield-subclass" title="Lien permanent vers ce titre">¶</a></h2>
<p>En plus des méthodes ci-dessus, les champs qui manipulent des fichiers doivent répondre à quelques exigences supplémentaires dont il faut tenir compte. La plupart des mécanismes fournis par <code class="docutils literal notranslate"><span class="pre">FileField</span></code>, comme la maîtrise du stockage en base de données et de la récupération des données, peuvent rester tels quels&nbsp;; il reste donc aux sous-classes la tâche pas toujours triviale de s’occuper de la prise en charge d’un type particulier de fichier.</p>
<p>Django propose une classe <code class="docutils literal notranslate"><span class="pre">File</span></code> utilisée comme intermédiaire et chargée de s’occuper des contenus des fichiers et de leurs opérations. Elle peut être la base de sous-classes qui peuvent personnaliser l’accès au fichier et les méthodes disponibles. Elle se trouve dans <code class="docutils literal notranslate"><span class="pre">django.db.models.fields.files</span></code> et son comportement par défaut est expliqué dans la <a class="reference internal" href="../ref/files/file.html"><span class="doc">documentation sur les fichiers</span></a>.</p>
<p>Quand une sous-classe de <code class="docutils literal notranslate"><span class="pre">File</span></code> a été créée, il s’agit d’indiquer à la nouvelle sous-classe de <code class="docutils literal notranslate"><span class="pre">FileField</span></code> qu’elle doit l’utiliser. Pour cela, définissez la nouvelle sous-classe de <code class="docutils literal notranslate"><span class="pre">File</span></code> dans l’attribut spécial <code class="docutils literal notranslate"><span class="pre">attr_class</span></code> de la sous-classe de <code class="docutils literal notranslate"><span class="pre">FileField</span></code>.</p>
<div class="section" id="s-a-few-suggestions">
<span id="a-few-suggestions"></span><h3>Quelques suggestions<a class="headerlink" href="#a-few-suggestions" title="Lien permanent vers ce titre">¶</a></h3>
<p>En plus des détails ci-dessus, voici quelques lignes de conduite qui peuvent grandement améliorer l’efficacité et la lisibilité du code du champ.</p>
<ol class="arabic simple">
<li>Le code source du champ <code class="docutils literal notranslate"><span class="pre">ImageField</span></code> de Django (dans <code class="docutils literal notranslate"><span class="pre">django/db/models/fields/files.py</span></code>) est un très bon exemple de la manière dont une sous-classe de <code class="docutils literal notranslate"><span class="pre">FileField</span></code> peut prendre en charge un type particulier de fichier, car elle tient compte de toutes les techniques décrites ci-dessus.</li>
<li>Mettez si possible en cache les attributs de fichier. Comme les fichiers peuvent être stockés sur des systèmes distants, leur accès peut impliquer des coûts de temps ou même financiers, ce qui n’est pas toujours nécessaire. Dès qu’un fichier est récupéré pour obtenir certaines informations sur son contenu, mettez le plus possible de ces données en cache pour réduire le nombre d’accès au fichier qui pourraient se produire lors d’éventuelles demandes futures pour ces mêmes informations.</li>
</ol>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Écriture de champs de modèles personnalisés</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#our-example-object">Notre exemple d’objet</a></li>
</ul>
</li>
<li><a class="reference internal" href="#background-theory">Contexte théorique</a><ul>
<li><a class="reference internal" href="#database-storage">Stockage de base de données</a></li>
<li><a class="reference internal" href="#what-does-a-field-class-do">Que fait une classe de champ&nbsp;?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-a-field-subclass">Écriture d’une sous-classe de champ</a><ul>
<li><a class="reference internal" href="#field-deconstruction">Déconstruction de champ</a></li>
<li><a class="reference internal" href="#changing-a-custom-field-s-base-class">Modification de la classe de base d’un champ personnalisé</a></li>
<li><a class="reference internal" href="#documenting-your-custom-field">Documentation du champ personnalisé</a></li>
<li><a class="reference internal" href="#useful-methods">Méthodes utiles</a><ul>
<li><a class="reference internal" href="#custom-database-types">Types de base de données personnalisés</a></li>
<li><a class="reference internal" href="#converting-values-to-python-objects">Conversion de valeurs en objets Python</a></li>
<li><a class="reference internal" href="#converting-python-objects-to-query-values">Conversion d’objets Python en valeurs de requête</a></li>
<li><a class="reference internal" href="#converting-query-values-to-database-values">Conversion de valeurs de requête en valeurs de base de données</a></li>
<li><a class="reference internal" href="#preprocessing-values-before-saving">Pré-traitement des valeurs avant enregistrement</a></li>
<li><a class="reference internal" href="#specifying-the-form-field-for-a-model-field">Sélection du champ de formulaire pour un champ de modèle</a></li>
<li><a class="reference internal" href="#emulating-built-in-field-types">Émulation de types de champs intégrés</a></li>
<li><a class="reference internal" href="#converting-field-data-for-serialization">Conversion des données de champs pour la sérialisation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#some-general-advice">Quelques conseils généraux</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-a-filefield-subclass">Écriture d’une sous-classe</a><ul>
<li><a class="reference internal" href="#a-few-suggestions">Quelques suggestions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Sujet précédent</h4>
  <p class="topless"><a href="custom-management-commands.html"
                        title="Chapitre précédent">Écriture de commandes <code class="docutils literal notranslate"><span class="pre">django-admin</span></code> personnalisées</a></p>
  <h4>Sujet suivant</h4>
  <p class="topless"><a href="custom-lookups.html"
                        title="Chapitre suivant">Expressions de recherche personnalisées</a></p>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/howto/custom-model-fields.txt"
            rel="nofollow">Montrer le code source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Recherche rapide</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">oct. 29, 2020</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="custom-management-commands.html" title="Écriture de commandes &lt;code class=&#34;docutils literal notranslate&#34;&gt;&lt;span class=&#34;pre&#34;&gt;django-admin&lt;/span&gt;&lt;/code&gt; personnalisées">previous</a>
     |
    <a href="index.html" title="Guides pratiques" accesskey="U">up</a>
   |
    <a href="custom-lookups.html" title="Expressions de recherche personnalisées">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>