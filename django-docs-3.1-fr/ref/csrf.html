
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Protection contre le « Cross site request forgery » (CSRF) &#8212; Documentation Django 3.1.3.dev</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="next" title="Bases de données" href="databases.html" />
    <link rel="prev" title="L’infrastructure de syndication par flux" href="contrib/syndication.html" />



 
<script src="../templatebuiltins.js"></script>
<script>
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);</script>

  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Documentation Django 3.1.3.dev</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">Home</a>  |
        <a title="Table of contents" href="../contents.html">Table of contents</a>  |
        <a title="Global index" href="../genindex.html">Index</a>  |
        <a title="Module index" href="../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="contrib/syndication.html" title="L’infrastructure de syndication par flux">previous</a>
     |
    <a href="index.html" title="Référence de l’API" accesskey="U">up</a>
   |
    <a href="databases.html" title="Bases de données">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="ref-csrf">
            
  <div class="section" id="s-module-django.middleware.csrf">
<span id="s-cross-site-request-forgery-protection"></span><span id="module-django.middleware.csrf"></span><span id="cross-site-request-forgery-protection"></span><h1>Protection contre le «&nbsp;Cross site request forgery&nbsp;» (CSRF)<a class="headerlink" href="#module-django.middleware.csrf" title="Lien permanent vers ce titre">¶</a></h1>
<p>L’intergiciel et les balises de gabarit CSRF permettent de se protéger facilement contre les attaques de type  <a class="reference external" href="https://www.squarefree.com/securitytips/web-developers.html#CSRF">Cross Site Request Forgeries</a>. Ce type d’attaque se produit quand un site Web malveillant contient un lien, un bouton de formulaire ou un peu de JavaScript qui est destiné à effectuer une action sur votre site Web, en utilisant les informations d’identification d’un utilisateur connecté qui visite le site malveillant dans son navigateur. Un type d’attaque liée est également couverte&nbsp;: celle du «&nbsp;login CSRF&nbsp;», où un site attaquant piège le navigateur d’un utilisateur en se connectant à un site avec les informations d’identification de quelqu’un d’autre.</p>
<p>La première ligne de défense contre les attaques CSRF est de s’assurer que les requêtes GET (et les autres méthodes «&nbsp;sûres&nbsp;», telles que définies par <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7231.html#section-4.2.1"><strong>RFC 7231#section-4.2.1</strong></a>) sont sans effet de bord. Les appels par des méthodes «&nbsp;non sûres&nbsp;», comme POST, PUT et DELETE, peuvent ensuite être protégés en suivant les étapes ci-dessous.</p>
<div class="section" id="s-how-to-use-it">
<span id="s-using-csrf"></span><span id="how-to-use-it"></span><span id="using-csrf"></span><h2>Comment l’utiliser<a class="headerlink" href="#how-to-use-it" title="Lien permanent vers ce titre">¶</a></h2>
<p>Pour profiter de la protection CSRF dans les vues, procédez comme suit&nbsp;:</p>
<ol class="arabic">
<li><p class="first">L’intergiciel CSRF est activé par défaut dans le réglage <a class="reference internal" href="settings.html#std:setting-MIDDLEWARE"><code class="xref std std-setting docutils literal notranslate"><span class="pre">MIDDLEWARE</span></code></a>. Si vous surchargez ce réglage, rappelez-vous que <code class="docutils literal notranslate"><span class="pre">'django.middleware.csrf.CsrfViewMiddleware'</span></code> doit figurer avant les intergiciels qui comptent sur le fait que les attaques CSRF ont déjà été contrées.</p>
<p>Si vous le désactivez, ce qui n’est pas recommandé, vous pouvez utiliser <a class="reference internal" href="#django.views.decorators.csrf.csrf_protect" title="django.views.decorators.csrf.csrf_protect"><code class="xref py py-func docutils literal notranslate"><span class="pre">csrf_protect()</span></code></a> sur certaines vues que vous souhaitez protéger (voir ci-dessous).</p>
</li>
<li><p class="first">Dans tout gabarit qui utilise un formulaire POST, utilisez la balise de gabarit <a class="reference internal" href="templates/builtins.html#std:templatetag-csrf_token"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">csrf_token</span></code></a> à l’intérieur de la balise HTML <code class="docutils literal notranslate"><span class="pre">&lt;form&gt;</span></code> si le formulaire renvoie vers une URL interne, par exemple&nbsp;:</p>
<div class="highlight-html+django notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">form</span> <span class="na">method</span><span class="o">=</span><span class="s">&quot;post&quot;</span><span class="p">&gt;</span><span class="cp">{%</span> <span class="k">csrf_token</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>Par contre, il ne faut pas le faire pour les formulaires POST qui ciblent des URL externes, car cela entraînerait la divulgation du jeton CSRF, et conduirait ainsi à une vulnérabilité.</p>
</li>
<li><p class="first">Dans les fonctions de vue correspondantes, vérifiez que <a class="reference internal" href="templates/api.html#django.template.RequestContext" title="django.template.RequestContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">RequestContext</span></code></a> est utilisé pour produire la réponse afin que <code class="docutils literal notranslate"><span class="pre">{%</span> <span class="pre">csrf_token</span> <span class="pre">%}</span></code> fonctionne correctement. Si vous utilisez la fonction <a class="reference internal" href="../topics/http/shortcuts.html#django.shortcuts.render" title="django.shortcuts.render"><code class="xref py py-func docutils literal notranslate"><span class="pre">render()</span></code></a>, les vues génériques ou les applications contribuées, il n’y a pas de soucis à se faire car toutes ces vues utilisent <code class="docutils literal notranslate"><span class="pre">RequestContext</span></code>.</p>
</li>
</ol>
<div class="section" id="s-ajax">
<span id="s-csrf-ajax"></span><span id="ajax"></span><span id="csrf-ajax"></span><h3>AJAX<a class="headerlink" href="#ajax" title="Lien permanent vers ce titre">¶</a></h3>
<p>Même si la méthode ci-dessus peut être utilisée pour les requêtes AJAX POST, elle présente quelques inconvénients&nbsp;: il ne faut pas oublier de passer le jeton CSRF en même temps que les données POST à ​​chaque requête POST. Pour cette raison, il y a une autre méthode&nbsp;: sur chaque XMLHttpRequest, définissez un élément d’en-tête <code class="docutils literal notranslate"><span class="pre">X-CSRFToken</span></code> (tel qu’indiqué par le réglage <a class="reference internal" href="settings.html#std:setting-CSRF_HEADER_NAME"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_HEADER_NAME</span></code></a>) ayant la même valeur que le jeton CSRF. C’est souvent plus simple, parce que de nombreuses bibliothèques JavaScript fournissent des points d’extension qui permettent d’ajouter des éléments d’en-tête pour chaque requête.</p>
<p>Il faut d’abord obtenir le jeton CSRF. La façon de faire dépend de l’activation ou non des réglages <a class="reference internal" href="settings.html#std:setting-CSRF_USE_SESSIONS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_USE_SESSIONS</span></code></a> et <a class="reference internal" href="settings.html#std:setting-CSRF_COOKIE_HTTPONLY"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_HTTPONLY</span></code></a>.</p>
<div class="section" id="s-acquiring-the-token-if-csrf-use-sessions-and-csrf-cookie-httponly-are-false">
<span id="s-acquiring-csrf-token-from-cookie"></span><span id="acquiring-the-token-if-csrf-use-sessions-and-csrf-cookie-httponly-are-false"></span><span id="acquiring-csrf-token-from-cookie"></span><h4>Acquisition du jeton si <a class="reference internal" href="settings.html#std:setting-CSRF_USE_SESSIONS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_USE_SESSIONS</span></code></a> et <a class="reference internal" href="settings.html#std:setting-CSRF_COOKIE_HTTPONLY"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_HTTPONLY</span></code></a> valent <code class="docutils literal notranslate"><span class="pre">False</span></code><a class="headerlink" href="#acquiring-the-token-if-csrf-use-sessions-and-csrf-cookie-httponly-are-false" title="Lien permanent vers ce titre">¶</a></h4>
<p>La source recommandée pour le jeton est le cookie <code class="docutils literal notranslate"><span class="pre">csrftoken</span></code>, qui sera présent si vous avez activé la protection CSRF pour votre vue, comme indiqué ci-dessus.</p>
<p>Le cookie CSRF est nommé <code class="docutils literal notranslate"><span class="pre">csrftoken</span></code> par défaut, mais vous pouvez modifier ce nom via le réglage <a class="reference internal" href="settings.html#std:setting-CSRF_COOKIE_NAME"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_NAME</span></code></a>.</p>
<p>Vous pouvez obtenir le jeton comme ceci :</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">getCookie</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">cookieValue</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">&amp;&amp;</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">!==</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">cookies</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">cookies</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kr">const</span> <span class="nx">cookie</span> <span class="o">=</span> <span class="nx">cookies</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">trim</span><span class="p">();</span>
            <span class="c1">// Does this cookie string begin with the name we want?</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">name</span><span class="p">.</span><span class="nx">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">===</span> <span class="p">(</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">cookieValue</span> <span class="o">=</span> <span class="nb">decodeURIComponent</span><span class="p">(</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">name</span><span class="p">.</span><span class="nx">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">cookieValue</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">csrftoken</span> <span class="o">=</span> <span class="nx">getCookie</span><span class="p">(</span><span class="s1">&#39;csrftoken&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>Le code ci-dessus pourrait être simplifié en utilisant la <a class="reference external" href="https://github.com/js-cookie/js-cookie/">bibliothèque JavaScript Cookie</a> pour remplacer <code class="docutils literal notranslate"><span class="pre">getCookie</span></code>:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">csrftoken</span> <span class="o">=</span> <span class="nx">Cookies</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;csrftoken&#39;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Le jeton CSRF est également présent dans le DOM, mais seulement s’il est explicitement inclus à l’aide de la balise <a class="reference internal" href="templates/builtins.html#std:templatetag-csrf_token"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">csrf_token</span></code></a> dans un gabarit. Le cookie contiendra le jeton standard&nbsp;; le <code class="docutils literal notranslate"><span class="pre">CsrfViewMiddleware</span></code> préfèrera le cookie au jeton du DOM. De toute façon, vous êtes assuré d’avoir le cookie si le jeton est présent dans le DOM, il est donc préférable d’utiliser le cookie&nbsp;!</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Avertissement</p>
<p class="last">Si la vue n’utilise pas un gabarit contenant la balise <a class="reference internal" href="templates/builtins.html#std:templatetag-csrf_token"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">csrf_token</span></code></a>, Django peut ne pas définir le cookie CSRF. Cette situation apparaît souvent dans les cas où les formulaires sont ajoutés dynamiquement à la page. Pour résoudre ce problème, Django fournit un décorateur de vue qui force l’utilisation du cookie&nbsp;: <a class="reference internal" href="#django.views.decorators.csrf.ensure_csrf_cookie" title="django.views.decorators.csrf.ensure_csrf_cookie"><code class="xref py py-func docutils literal notranslate"><span class="pre">ensure_csrf_cookie()</span></code></a>.</p>
</div>
</div>
<div class="section" id="s-acquiring-the-token-if-csrf-use-sessions-or-csrf-cookie-httponly-is-true">
<span id="s-acquiring-csrf-token-from-html"></span><span id="acquiring-the-token-if-csrf-use-sessions-or-csrf-cookie-httponly-is-true"></span><span id="acquiring-csrf-token-from-html"></span><h4>Acquisition du jeton si <a class="reference internal" href="settings.html#std:setting-CSRF_USE_SESSIONS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_USE_SESSIONS</span></code></a> ou <a class="reference internal" href="settings.html#std:setting-CSRF_COOKIE_HTTPONLY"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_HTTPONLY</span></code></a> vaut <code class="docutils literal notranslate"><span class="pre">True</span></code><a class="headerlink" href="#acquiring-the-token-if-csrf-use-sessions-or-csrf-cookie-httponly-is-true" title="Lien permanent vers ce titre">¶</a></h4>
<p>Si vous activez <a class="reference internal" href="settings.html#std:setting-CSRF_USE_SESSIONS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_USE_SESSIONS</span></code></a> ou <a class="reference internal" href="settings.html#std:setting-CSRF_COOKIE_HTTPONLY"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_HTTPONLY</span></code></a>, vous devez inclure le jeton CSRF dans le code HTML et lire le jeton dans le DOM en JavaScript&nbsp;:</p>
<div class="highlight-html+django notranslate"><div class="highlight"><pre><span></span><span class="cp">{%</span> <span class="k">csrf_token</span> <span class="cp">%}</span>
<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="kr">const</span> <span class="nx">csrftoken</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;[name=csrfmiddlewaretoken]&#39;</span><span class="p">).</span><span class="nx">value</span><span class="p">;</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="s-setting-the-token-on-the-ajax-request">
<span id="setting-the-token-on-the-ajax-request"></span><h4>Définition du jeton pour une requête AJAX<a class="headerlink" href="#setting-the-token-on-the-ajax-request" title="Lien permanent vers ce titre">¶</a></h4>
<p>Enfin, vous devrez renseigner l’en-tête de votre requête AJAX. En utilisant l’API <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">fetch()</a> :</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Request</span><span class="p">(</span>
    <span class="cm">/* URL */</span><span class="p">,</span>
    <span class="p">{</span><span class="nx">headers</span><span class="o">:</span> <span class="p">{</span><span class="s1">&#39;X-CSRFToken&#39;</span><span class="o">:</span> <span class="nx">csrftoken</span><span class="p">}}</span>
<span class="p">);</span>
<span class="nx">fetch</span><span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">method</span><span class="o">:</span> <span class="s1">&#39;POST&#39;</span><span class="p">,</span>
    <span class="nx">mode</span><span class="o">:</span> <span class="s1">&#39;same-origin&#39;</span>  <span class="c1">// Do not send CSRF token to another domain.</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-using-csrf-in-jinja2-templates">
<span id="using-csrf-in-jinja2-templates"></span><h3>Utilisation de CSRF dans les gabarits Jinja2<a class="headerlink" href="#using-csrf-in-jinja2-templates" title="Lien permanent vers ce titre">¶</a></h3>
<p>Le moteur de gabarit <a class="reference internal" href="../topics/templates.html#django.template.backends.jinja2.Jinja2" title="django.template.backends.jinja2.Jinja2"><code class="xref py py-class docutils literal notranslate"><span class="pre">Jinja2</span></code></a> de Django ajoute <code class="docutils literal notranslate"><span class="pre">{{</span> <span class="pre">csrf_input</span> <span class="pre">}}</span></code> au contexte de tous les gabarits, ce qui est équivalent à <code class="docutils literal notranslate"><span class="pre">{%</span> <span class="pre">csrf_token</span> <span class="pre">%}</span></code> dans le langage de gabarit de Django. Par exemple&nbsp;:</p>
<div class="highlight-html+jinja notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">form</span> <span class="na">method</span><span class="o">=</span><span class="s">&quot;post&quot;</span><span class="p">&gt;</span><span class="cp">{{</span> <span class="nv">csrf_input</span> <span class="cp">}}</span>
</pre></div>
</div>
</div>
<div class="section" id="s-module-django.views.decorators.csrf">
<span id="s-the-decorator-method"></span><span id="module-django.views.decorators.csrf"></span><span id="the-decorator-method"></span><h3>La méthode du décorateur<a class="headerlink" href="#module-django.views.decorators.csrf" title="Lien permanent vers ce titre">¶</a></h3>
<p>Plutôt que d’ajouter <code class="docutils literal notranslate"><span class="pre">CsrfViewMiddleware</span></code> comme une protection générale, vous pouvez utiliser le décorateur <code class="docutils literal notranslate"><span class="pre">csrf_protect</span></code>, qui offre exactement la même fonctionnalité, sur les vues particulières qui ont besoin de la protection. Ce décorateur doit être utilisé <strong>à la fois</strong> sur les vues qui insèrent le jeton CSRF dans leur rendu, et sur celles qui acceptent les données de formulaire POST. (Il s’agit souvent de la même fonction de vue, mais pas toujours).</p>
<p>Le recours à l’utilisation seule du décorateur <strong>n’est pas recommandé</strong>, car si vous oubliez de l’utiliser, vous aurez un trou de sécurité. La stratégie «&nbsp;ceinture et bretelles&nbsp;» qui consiste à utiliser les deux convient tout à fait et n’entraînera qu’une surcharge minimale.</p>
<dl class="function">
<dt id="django.views.decorators.csrf.csrf_protect">
<code class="descname">csrf_protect</code>(<em>view</em>)<a class="headerlink" href="#django.views.decorators.csrf.csrf_protect" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Décorateur qui fournit la protection similaire à l’intergiciel <code class="docutils literal notranslate"><span class="pre">CsrfViewMiddleware</span></code> pour une vue.</p>
<p>Utilisation&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.shortcuts</span> <span class="k">import</span> <span class="n">render</span>
<span class="kn">from</span> <span class="nn">django.views.decorators.csrf</span> <span class="k">import</span> <span class="n">csrf_protect</span>

<span class="nd">@csrf_protect</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">render</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="s2">&quot;a_template.html&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>Si vous utilisez des vues fondées sur les classes, vous pouvez vous référer à la <a class="reference internal" href="../topics/class-based-views/intro.html#id1"><span class="std std-ref">Décoration des vues fondées sur les classes</span></a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="s-rejected-requests">
<span id="s-csrf-rejected-requests"></span><span id="rejected-requests"></span><span id="csrf-rejected-requests"></span><h2>Requêtes rejetées<a class="headerlink" href="#rejected-requests" title="Lien permanent vers ce titre">¶</a></h2>
<p>Par défaut, une réponse de type «&nbsp;403 Forbidden&nbsp;» est renvoyée à l’utilisateur si une requête entrante ne satisfait pas les contrôles effectués par <code class="docutils literal notranslate"><span class="pre">CsrfViewMiddleware</span></code>. Ça ne devrait généralement apparaître que lorsqu’il s’agit d’une véritable attaque de type «&nbsp;Cross Site Request Forgery&nbsp;», ou lorsqu’en raison d’une erreur de programmation, le jeton CSRF n’a pas été inclus dans un formulaire de type POST.</p>
<p>La page d’erreur n’est toutefois pas très sympathique, de sorte que vous pouvez fournir votre propre vue pour traiter cette condition. Pour ce faire, définissez le réglage <a class="reference internal" href="settings.html#std:setting-CSRF_FAILURE_VIEW"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_FAILURE_VIEW</span></code></a>.</p>
<p>Les échecs CSRF sont journalisés comme avertissements dans le journaliseur <a class="reference internal" href="../topics/logging.html#django-security-logger"><span class="std std-ref">django.security.csrf</span></a>.</p>
</div>
<div class="section" id="s-how-it-works">
<span id="s-how-csrf-works"></span><span id="how-it-works"></span><span id="how-csrf-works"></span><h2>Fonctionnement<a class="headerlink" href="#how-it-works" title="Lien permanent vers ce titre">¶</a></h2>
<p>La protection CSRF est basée sur les éléments suivants&nbsp;:</p>
<ol class="arabic">
<li><p class="first">Un cookie CSRF qui est basé sur une valeur secrète aléatoire auquel les autres sites n’auront pas accès.</p>
<p>Ce cookie est créé par l’intergiciel <code class="docutils literal notranslate"><span class="pre">CsrfViewMiddleware</span></code>. Il est envoyé avec chaque réponse qui a appelé <code class="docutils literal notranslate"><span class="pre">django.middleware.csrf.get_token()</span></code> (la fonction utilisée en interne pour récupérer le jeton CSRF), s’il n’a pas déjà été défini pour la requête.</p>
<p>Afin de protéger contre les attaques <a class="reference external" href="http://breachattack.com/">BREACH</a>, le jeton n’est pas simplement la valeur secrète&nbsp;; un masque aléatoire est préfixé à la valeur et utilisé pour le brouiller.</p>
<p>Pour des raisons de sécurité, la valeur secrète est modifiée chaque fois qu’un utilisateur se connecte.</p>
</li>
<li><p class="first">Un champ de formulaire masqué nommé <code class="docutils literal notranslate"><span class="pre">csrfmiddlewaretoken</span></code> et présent dans tous les formulaires POST sortants. La valeur de ce champ est, encore une fois, la valeur secrète avec un masque qui est ajouté et utilisé pour le brouiller. Le masque est régénéré à chaque appel à <code class="docutils literal notranslate"><span class="pre">get_token()</span></code> afin que la valeur de champ de formulaire soit modifiée dans chacune des réponses.</p>
<p>Cette action est effectuée par la balise de gabarit.</p>
</li>
<li><p class="first">Pour toutes les requêtes entrantes qui n’utilisent pas les méthodes HTTP GET, HEAD, OPTIONS ou TRACE, un cookie CSRF doit être présent, et le champ «&nbsp;csrfmiddlewaretoken&nbsp;» doit être présent et correct. Si ce n’est pas le cas, l’utilisateur obtiendra une erreur 403.</p>
<p>Lors de la validation de la valeur de champ <code class="docutils literal notranslate"><span class="pre">csrfmiddlewaretoken</span></code>, seule la valeur secrète, et non pas le jeton complet, est comparée avec la valeur secrète du contenu du cookie. Cela permet d’utiliser des jetons qui changent constamment. Alors que chaque requête peut utiliser son propre jeton, la valeur secrète reste commune à toutes.</p>
<p>Cette vérification est effectuée par l’intergiciel <code class="docutils literal notranslate"><span class="pre">CsrfViewMiddleware</span></code>.</p>
</li>
<li><p class="first">De plus, pour les requêtes HTTPS, le contrôle strict du référant est effectué par <code class="docutils literal notranslate"><span class="pre">CsrfViewMiddleware</span></code>. Cela signifie que même si un sous-domaine peut définir ou modifier des cookies pour votre domaine, il ne peut pas forcer un utilisateur à envoyer des données à votre application car cette requête ne viendrait pas de votre domaine exact.</p>
<p>Cela protège aussi contre une attaque de type «&nbsp;Man-In-The-Middle&nbsp;» qui est possible sous HTTPS lors de l’utilisation d’une valeur secrète indépendante de la session, parce que les en-têtes HTTP <code class="docutils literal notranslate"><span class="pre">Set-Cookie</span></code> sont (malheureusement) acceptés par les clients, même quand ils parlent à un site en HTTPS. (La vérification du référant n’est pas faite pour les requêtes HTTP car la présence de l’en-tête <code class="docutils literal notranslate"><span class="pre">Referer</span></code> n’est pas suffisamment fiable sous HTTP.)</p>
<p>Si le réglage <a class="reference internal" href="settings.html#std:setting-CSRF_COOKIE_DOMAIN"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_DOMAIN</span></code></a> est défini, le référant est comparé avec lui. Il est possible d’autoriser les requêtes inter-domaines en incluant un point en premier. Par exemple, <code class="docutils literal notranslate"><span class="pre">CSRF_COOKIE_DOMAIN</span> <span class="pre">=</span> <span class="pre">'.exemple.com'</span></code> autorise les requêtes POST depuis <code class="docutils literal notranslate"><span class="pre">www.exemple.com</span></code> et <code class="docutils literal notranslate"><span class="pre">api.exemple.com</span></code>. Si le réglage n’est pas défini, le référant doit alors correspondre à l’en-tête HTTP <code class="docutils literal notranslate"><span class="pre">Host</span></code>.</p>
<p>L’extension des référants acceptés au-delà de l’hôte courant ou du domaine du cookie peut se faire avec le réglage <a class="reference internal" href="settings.html#std:setting-CSRF_TRUSTED_ORIGINS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_TRUSTED_ORIGINS</span></code></a>.</p>
</li>
</ol>
<p>Cela garantit que seuls les formulaires originaires de domaines de confiance peuvent être utilisés pour renvoyer des données avec une requête POST.</p>
<p>Les requêtes GET sont volontairement ignorées (ainsi que les autres requêtes définies comme «&nbsp;sûres&nbsp;» par la <span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7231.html#section-4.2.1"><strong>RFC 7231#section-4.2.1</strong></a>). Ces requêtes ne devraivent jamais avoir d’effets secondaires potentiellement dangereux, et de cette manière une attaque CSRF avec une requête GET doit être inoffensive. La <span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7231.html#section-4.2.1"><strong>RFC 7231#section-4.2.1</strong></a> définit les méthodes POST, PUT et DELETE comme « non sûres », et toutes les autres méthodes sont aussi supposées être dangereuses, pour que la protection soit maximale.</p>
<p>La protection CRSF ne peut pas protéger contre les attaques de «&nbsp;l’homme du milieu&nbsp;», c’est pourquoi il faut utiliser <a class="reference internal" href="../topics/security.html#security-recommendation-ssl"><span class="std std-ref">HTTPS</span></a> avec <a class="reference internal" href="middleware.html#http-strict-transport-security"><span class="std std-ref">Sécurité de transport HTTP stricte (HSTS)</span></a>. Il suppose également la <a class="reference internal" href="../topics/security.html#host-headers-virtual-hosting"><span class="std std-ref">validation de l’en-tête HOST</span></a> et que le site ne comporte pas de <a class="reference internal" href="../topics/security.html#cross-site-scripting"><span class="std std-ref">vulnérabilités de scripts inter-sites</span></a> (parce que ce type de vulnérabilité permet déjà à un attaquant de faire ce qu’une vulnérabilité CSRF permet de faire, et plus encore).</p>
<div class="admonition-removing-the-referer-header admonition">
<p class="first admonition-title">Suppression de l’en-tête <code class="docutils literal notranslate"><span class="pre">Referer</span></code></p>
<p class="last">Pour éviter de divulguer l’URL référent à des sites tiers, il peut être souhaitable de <a class="reference external" href="https://www.w3.org/TR/referrer-policy/#referrer-policy-delivery">désactiver le référent</a> dans les balises <code class="docutils literal notranslate"><span class="pre">&lt;a&gt;</span></code> de votre site. Par exemple, il est possible d’utiliser la balise <code class="docutils literal notranslate"><span class="pre">&lt;meta</span> <span class="pre">name=&quot;referrer&quot;</span> <span class="pre">content=&quot;no-referrer&quot;&gt;</span></code> ou d’inclure l’en-tête <code class="docutils literal notranslate"><span class="pre">Referrer-Policy:</span> <span class="pre">no-referrer</span></code>. En raison du contrôle strict du référent dans la protection CSRF pour les requêtes HTTPS, ces techniques produisent des échecs CSRF pour les requêtes de méthodes « non sûres ». Il est préférable d’utiliser des alternatives telles que <code class="docutils literal notranslate"><span class="pre">&lt;a</span> <span class="pre">rel=&quot;noreferrer&quot;</span> <span class="pre">...&gt;&quot;</span></code> pour les liens vers des sites tiers.</p>
</div>
</div>
<div class="section" id="s-caching">
<span id="caching"></span><h2>Mise en cache<a class="headerlink" href="#caching" title="Lien permanent vers ce titre">¶</a></h2>
<p>Si la balise de gabarit <a class="reference internal" href="templates/builtins.html#std:templatetag-csrf_token"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">csrf_token</span></code></a> est utilisée par un gabarit (ou que la fonction <code class="docutils literal notranslate"><span class="pre">get_token</span></code> est appelée d’une autre façon), l’intergiciel <code class="docutils literal notranslate"><span class="pre">CsrfViewMiddleware</span></code> ajoute un cookie et un en-tête <code class="docutils literal notranslate"><span class="pre">Vary:</span> <span class="pre">Cookie</span></code> à la réponse. Cela signifie que l’intergiciel fonctionnera bien avec l’intergiciel de cache s’il est utilisé conformément aux instructions (<code class="docutils literal notranslate"><span class="pre">UpdateCacheMiddleware</span></code> doit être placé dans les réglages avant tout autre intergiciel).</p>
<p>Toutefois, si vous utilisez des décorateurs de cache sur des vues individuelles, l’intergiciel CSRF n’aura pas encore pu définir l’en-tête Vary ou le cookie CSRF, et la réponse sera mise en cache sans l’un ni l’autre. Dans ce cas, sur les vues qui nécessitent qu’un jeton CSRF soit inséré, vous devez utiliser le décorateur de fonction <a class="reference internal" href="#django.views.decorators.csrf.csrf_protect" title="django.views.decorators.csrf.csrf_protect"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.views.decorators.csrf.csrf_protect()</span></code></a> en premier&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.views.decorators.cache</span> <span class="k">import</span> <span class="n">cache_page</span>
<span class="kn">from</span> <span class="nn">django.views.decorators.csrf</span> <span class="k">import</span> <span class="n">csrf_protect</span>

<span class="nd">@cache_page</span><span class="p">(</span><span class="mi">60</span> <span class="o">*</span> <span class="mi">15</span><span class="p">)</span>
<span class="nd">@csrf_protect</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Si vous utilisez des vues fondées sur les classes, vous pouvez vous référer à la <a class="reference internal" href="../topics/class-based-views/intro.html#id1"><span class="std std-ref">Décoration des vues fondées sur les classes</span></a>.</p>
</div>
<div class="section" id="s-testing">
<span id="testing"></span><h2>Tests<a class="headerlink" href="#testing" title="Lien permanent vers ce titre">¶</a></h2>
<p>Généralement, <code class="docutils literal notranslate"><span class="pre">CsrfViewMiddleware</span></code> gêne les tests des fonctions de vues, parce que le jeton CSRF doit être envoyé avec chaque requête POST. Le client HTTP de Django utilisé pour les tests a donc été modifié afin de marquer automatiquement les requêtes et ainsi d’informer l’intergiciel et le décorateur <code class="docutils literal notranslate"><span class="pre">csrf_protect</span></code> de manière à ce qu’ils ne rejettent pas ces requêtes. À tous les autres égards (par exemple, l’envoi des cookies, etc.), le comportement durant les tests est identique.</p>
<p>Si pour une raison quelconque vous <em>voulez</em> que le client HTTP utilisé pour les tests effectue des contrôles CSRF, vous pouvez créer une instance du client de test qui applique les vérifications CSRF&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.test</span> <span class="k">import</span> <span class="n">Client</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">csrf_client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">enforce_csrf_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-limitations">
<span id="s-csrf-limitations"></span><span id="limitations"></span><span id="csrf-limitations"></span><h2>Limitations<a class="headerlink" href="#limitations" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les sous-domaines d’un site peuvent placer des cookies sur le client pour l’ensemble du domaine. En définissant le cookie et en utilisant le jeton correspondant, les sous-domaines seront en mesure de contourner la protection CSRF. La seule façon d’éviter cela est de s’assurer que les sous-domaines sont contrôlés par des utilisateurs de confiance (ou, au moins ne sont pas en mesure de définir des cookies). Notez que même sans CSRF, il existe d’autres vulnérabilités, comme la fixation de session, qui font que donner des sous-domaines à des tierces parties non sûres est une mauvaise idée&nbsp;; ces vulnérabilités ne peuvent pas facilement être résolues avec les navigateurs actuels.</p>
</div>
<div class="section" id="s-edge-cases">
<span id="edge-cases"></span><h2>Cas particuliers<a class="headerlink" href="#edge-cases" title="Lien permanent vers ce titre">¶</a></h2>
<p>Certaines vues peuvent avoir des exigences inhabituelles qui impliquent qu’elles ne correspondent pas au modèle normal envisagé ici. Un certain nombre d’utilitaires peuvent être utiles dans ces situations. Les scénarios qui pourraient alors être nécessaires sont décrits dans la section suivante.</p>
<div class="section" id="s-utilities">
<span id="utilities"></span><h3>Utilitaires<a class="headerlink" href="#utilities" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les exemples ci-dessous s’appliquent à des vues basées sur des fonctions. Si vous utilisez des vues fondées sur les classes, vous pouvez vous référer à la <a class="reference internal" href="../topics/class-based-views/intro.html#id1"><span class="std std-ref">Décoration des vues fondées sur les classes</span></a>.</p>
<dl class="function">
<dt id="django.views.decorators.csrf.csrf_exempt">
<code class="descname">csrf_exempt</code>(<em>view</em>)<a class="headerlink" href="#django.views.decorators.csrf.csrf_exempt" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ce décorateur marque une vue comme étant exempte de la protection assurée par l’intergiciel. Exemple&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.http</span> <span class="k">import</span> <span class="n">HttpResponse</span>
<span class="kn">from</span> <span class="nn">django.views.decorators.csrf</span> <span class="k">import</span> <span class="n">csrf_exempt</span>

<span class="nd">@csrf_exempt</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">HttpResponse</span><span class="p">(</span><span class="s1">&#39;Hello world&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="django.views.decorators.csrf.requires_csrf_token">
<code class="descname">requires_csrf_token</code>(<em>view</em>)<a class="headerlink" href="#django.views.decorators.csrf.requires_csrf_token" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Normalement, la balise de gabarit <a class="reference internal" href="templates/builtins.html#std:templatetag-csrf_token"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">csrf_token</span></code></a> ne fonctionnera pas si  <code class="docutils literal notranslate"><span class="pre">CsrfViewMiddleware.process_view</span></code> ou un équivalent comme  <code class="docutils literal notranslate"><span class="pre">csrf_protect</span></code> n’a pas été utilisé. Le décorateur de vue <code class="docutils literal notranslate"><span class="pre">requires_csrf_token</span></code> peut être utilisé pour s’assurer que la balise de gabarit fonctionne. Ce décorateur fonctionne de façon similaire à <code class="docutils literal notranslate"><span class="pre">csrf_protect</span></code>, mais ne rejette jamais une demande entrante.</p>
<p>Exemple&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.shortcuts</span> <span class="k">import</span> <span class="n">render</span>
<span class="kn">from</span> <span class="nn">django.views.decorators.csrf</span> <span class="k">import</span> <span class="n">requires_csrf_token</span>

<span class="nd">@requires_csrf_token</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">render</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="s2">&quot;a_template.html&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="django.views.decorators.csrf.ensure_csrf_cookie">
<code class="descname">ensure_csrf_cookie</code>(<em>view</em>)<a class="headerlink" href="#django.views.decorators.csrf.ensure_csrf_cookie" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ce décorateur force une vue à envoyer le cookie CSRF.</p>
</dd></dl>

</div>
<div class="section" id="s-scenarios">
<span id="scenarios"></span><h3>Scénarios<a class="headerlink" href="#scenarios" title="Lien permanent vers ce titre">¶</a></h3>
<div class="section" id="s-csrf-protection-should-be-disabled-for-just-a-few-views">
<span id="csrf-protection-should-be-disabled-for-just-a-few-views"></span><h4>La protection CSRF doit être désactivée pour quelques vues<a class="headerlink" href="#csrf-protection-should-be-disabled-for-just-a-few-views" title="Lien permanent vers ce titre">¶</a></h4>
<p>La plupart des vues nécessitent une protection CSRF, mais quelques-unes n’en ont pas besoin.</p>
<p>Solution&nbsp;: plutôt que de désactiver l’intergiciel et d’appliquer <code class="docutils literal notranslate"><span class="pre">csrf_protect</span></code> à toutes les vues qui en ont besoin, activez l’intergiciel et utilisez <a class="reference internal" href="#django.views.decorators.csrf.csrf_exempt" title="django.views.decorators.csrf.csrf_exempt"><code class="xref py py-func docutils literal notranslate"><span class="pre">csrf_exempt()</span></code></a>.</p>
</div>
<div class="section" id="s-csrfviewmiddleware-process-view-not-used">
<span id="csrfviewmiddleware-process-view-not-used"></span><h4>CsrfViewMiddleware.process_view non utilisé<a class="headerlink" href="#csrfviewmiddleware-process-view-not-used" title="Lien permanent vers ce titre">¶</a></h4>
<p>Il y a des cas où <code class="docutils literal notranslate"><span class="pre">CsrfViewMiddleware.process_view</span></code> n’aura pas été exécuté avant votre vue - les gestionnaires d’erreurs 404 et 500, par exemple - mais vous avez quand même besoin du jeton CSRF dans un formulaire.</p>
<p>Solution&nbsp;: utilisez <a class="reference internal" href="#django.views.decorators.csrf.requires_csrf_token" title="django.views.decorators.csrf.requires_csrf_token"><code class="xref py py-func docutils literal notranslate"><span class="pre">requires_csrf_token()</span></code></a></p>
</div>
<div class="section" id="s-unprotected-view-needs-the-csrf-token">
<span id="unprotected-view-needs-the-csrf-token"></span><h4>Une vue non protégée nécessite le jeton CSRF<a class="headerlink" href="#unprotected-view-needs-the-csrf-token" title="Lien permanent vers ce titre">¶</a></h4>
<p>Certaines vues peuvent ne pas être protégées, peut-être exemptées par <code class="docutils literal notranslate"><span class="pre">csrf_exempt</span></code>, mais ont tout de même besoin d’inclure le jeton CSRF.</p>
<p>Solution&nbsp;: utilisez <a class="reference internal" href="#django.views.decorators.csrf.csrf_exempt" title="django.views.decorators.csrf.csrf_exempt"><code class="xref py py-func docutils literal notranslate"><span class="pre">csrf_exempt()</span></code></a> suivi de <a class="reference internal" href="#django.views.decorators.csrf.requires_csrf_token" title="django.views.decorators.csrf.requires_csrf_token"><code class="xref py py-func docutils literal notranslate"><span class="pre">requires_csrf_token()</span></code></a> (c’est à dire que <code class="docutils literal notranslate"><span class="pre">requires_csrf_token</span></code> doit être le décorateur le plus à l’intérieur).</p>
</div>
<div class="section" id="s-view-needs-protection-for-one-path">
<span id="view-needs-protection-for-one-path"></span><h4>Une vue a besoin de protection pour un chemin particulier<a class="headerlink" href="#view-needs-protection-for-one-path" title="Lien permanent vers ce titre">¶</a></h4>
<p>Une vue a besoin de protection CSRF seulement quand un certain nombre de conditions sont remplies, et ne doit pas être protégée le reste du temps.</p>
<p>Solution&nbsp;: utilisez <a class="reference internal" href="#django.views.decorators.csrf.csrf_exempt" title="django.views.decorators.csrf.csrf_exempt"><code class="xref py py-func docutils literal notranslate"><span class="pre">csrf_exempt()</span></code></a> pour l’ensemble de la fonction de vue, et <a class="reference internal" href="#django.views.decorators.csrf.csrf_protect" title="django.views.decorators.csrf.csrf_protect"><code class="xref py py-func docutils literal notranslate"><span class="pre">csrf_protect()</span></code></a> spécifiquement pour le chemin qui doit être protégé. Exemple&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.views.decorators.csrf</span> <span class="k">import</span> <span class="n">csrf_exempt</span><span class="p">,</span> <span class="n">csrf_protect</span>

<span class="nd">@csrf_exempt</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>

    <span class="nd">@csrf_protect</span>
    <span class="k">def</span> <span class="nf">protected_path</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
        <span class="n">do_something</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">some_condition</span><span class="p">():</span>
       <span class="k">return</span> <span class="n">protected_path</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="n">do_something_else</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-page-uses-ajax-without-any-html-form">
<span id="page-uses-ajax-without-any-html-form"></span><h4>Une page utilise de l’AJAX sans aucun formulaire HTML<a class="headerlink" href="#page-uses-ajax-without-any-html-form" title="Lien permanent vers ce titre">¶</a></h4>
<p>Une page effectue une requête POST via AJAX, et cette page n’a pas de formulaire HTML avec une balise <a class="reference internal" href="templates/builtins.html#std:templatetag-csrf_token"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">csrf_token</span></code></a> qui provoquerait la transmission du cookie CSRF.</p>
<p>Solution&nbsp;: utilisez <a class="reference internal" href="#django.views.decorators.csrf.ensure_csrf_cookie" title="django.views.decorators.csrf.ensure_csrf_cookie"><code class="xref py py-func docutils literal notranslate"><span class="pre">ensure_csrf_cookie()</span></code></a> sur la vue qui envoie la page.</p>
</div>
</div>
</div>
<div class="section" id="s-contrib-and-reusable-apps">
<span id="contrib-and-reusable-apps"></span><h2>Applications intégrées et applications réutilisables<a class="headerlink" href="#contrib-and-reusable-apps" title="Lien permanent vers ce titre">¶</a></h2>
<p>Comme il est possible pour le développeur de désactiver l’intergiciel <code class="docutils literal notranslate"><span class="pre">CsrfViewMiddleware</span></code>, toutes les vues concernées dans les applications «&nbsp;contrib&nbsp;» de Django utilisent le décorateur <code class="docutils literal notranslate"><span class="pre">csrf_protect</span></code> pour garantir la protection de ces applications contre les attaques CSRF. Il est recommandé que les développeurs d’autres applications réutilisables qui souhaitent offrir les mêmes garanties utilisent également le décorateur <code class="docutils literal notranslate"><span class="pre">csrf_protect</span></code> sur leurs vues.</p>
</div>
<div class="section" id="s-settings">
<span id="settings"></span><h2>Réglages<a class="headerlink" href="#settings" title="Lien permanent vers ce titre">¶</a></h2>
<p>Un certain nombre de réglages peuvent être utilisés pour contrôler le comportement anti-CSRF de Django&nbsp;:</p>
<ul class="simple">
<li><a class="reference internal" href="settings.html#std:setting-CSRF_COOKIE_AGE"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_AGE</span></code></a></li>
<li><a class="reference internal" href="settings.html#std:setting-CSRF_COOKIE_DOMAIN"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_DOMAIN</span></code></a></li>
<li><a class="reference internal" href="settings.html#std:setting-CSRF_COOKIE_HTTPONLY"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_HTTPONLY</span></code></a></li>
<li><a class="reference internal" href="settings.html#std:setting-CSRF_COOKIE_NAME"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_NAME</span></code></a></li>
<li><a class="reference internal" href="settings.html#std:setting-CSRF_COOKIE_PATH"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_PATH</span></code></a></li>
<li><a class="reference internal" href="settings.html#std:setting-CSRF_COOKIE_SAMESITE"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_SAMESITE</span></code></a></li>
<li><a class="reference internal" href="settings.html#std:setting-CSRF_COOKIE_SECURE"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_SECURE</span></code></a></li>
<li><a class="reference internal" href="settings.html#std:setting-CSRF_FAILURE_VIEW"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_FAILURE_VIEW</span></code></a></li>
<li><a class="reference internal" href="settings.html#std:setting-CSRF_HEADER_NAME"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_HEADER_NAME</span></code></a></li>
<li><a class="reference internal" href="settings.html#std:setting-CSRF_TRUSTED_ORIGINS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_TRUSTED_ORIGINS</span></code></a></li>
<li><a class="reference internal" href="settings.html#std:setting-CSRF_USE_SESSIONS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_USE_SESSIONS</span></code></a></li>
</ul>
</div>
<div class="section" id="s-frequently-asked-questions">
<span id="frequently-asked-questions"></span><h2>Questions fréquentes<a class="headerlink" href="#frequently-asked-questions" title="Lien permanent vers ce titre">¶</a></h2>
<div class="section" id="s-is-posting-an-arbitrary-csrf-token-pair-cookie-and-post-data-a-vulnerability">
<span id="is-posting-an-arbitrary-csrf-token-pair-cookie-and-post-data-a-vulnerability"></span><h3>Est-ce que l’envoi d’une paire de jetons CSRF arbitraires (cookie et données POST) est une vulnérabilité&nbsp;?<a class="headerlink" href="#is-posting-an-arbitrary-csrf-token-pair-cookie-and-post-data-a-vulnerability" title="Lien permanent vers ce titre">¶</a></h3>
<p>Non, délibérément pas. Sans attaque de «&nbsp;l’homme du milieu&nbsp;», il n’existe aucune possibilité pour un attaquant d’envoyer un cookie de jeton CSRF à destination du navigateur de sa victime&nbsp;; une attaque réussie devrait pouvoir obtenir le cookie du navigateur de la victime par XSS ou autre moyen similaire, auquel cas l’attaquant n’a généralement pas besoin d’attaquer par CSRF.</p>
<p>Certains outils d’audit de sécurité le signalent comme un problème, mais comme mentionné ci-dessus, un attaquant ne peut pas voler un cookie CSRF du navigateur d’un utilisateur. Pouvoir «&nbsp;voler&nbsp;» ou modifier son propre jeton à l’aide de Firebug, des outils de développement Chrome, etc. ne signifie pas qu’il s’agit d’une vulnérabilité.</p>
</div>
<div class="section" id="s-is-it-a-problem-that-django-s-csrf-protection-isn-t-linked-to-a-session-by-default">
<span id="is-it-a-problem-that-django-s-csrf-protection-isn-t-linked-to-a-session-by-default"></span><h3>Est-il problématique que la protection CSRF de Django n’est pas liée à une session par défaut&nbsp;?<a class="headerlink" href="#is-it-a-problem-that-django-s-csrf-protection-isn-t-linked-to-a-session-by-default" title="Lien permanent vers ce titre">¶</a></h3>
<p>Non, délibérément pas. Le fait de ne pas lier la protection CSRF à une session permet d’utiliser la protection sur des sites tels que <em>pastebin</em> qui autorisent des envois de données par des utilisateurs anonymes et qui n’ont pas de session.</p>
<p>Si vous souhaitez stocker le jeton CSRF dans la session de l’utilisateur, définissez le réglage <a class="reference internal" href="settings.html#std:setting-CSRF_USE_SESSIONS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_USE_SESSIONS</span></code></a>.</p>
</div>
<div class="section" id="s-why-might-a-user-encounter-a-csrf-validation-failure-after-logging-in">
<span id="why-might-a-user-encounter-a-csrf-validation-failure-after-logging-in"></span><h3>Pourquoi un utilisateur peut-il recevoir une erreur de validation CSRF après s’être connecté&nbsp;?<a class="headerlink" href="#why-might-a-user-encounter-a-csrf-validation-failure-after-logging-in" title="Lien permanent vers ce titre">¶</a></h3>
<p>Pour des raisons de sécurité, les jetons CSRF subissent une rotation lors de chque connexion d’utilisateur. Toute page contenant un formulaire généré avant une connexion possédera un ancien jeton CSRF non valide et devra être rechargée. Cela peut arriver si un utilisateur utilise le bouton «&nbsp;Retour&nbsp;» après une connexion ou s’il se connecte dans un autre onglet du navigateur.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Protection contre le «&nbsp;Cross site request forgery&nbsp;» (CSRF)</a><ul>
<li><a class="reference internal" href="#how-to-use-it">Comment l’utiliser</a><ul>
<li><a class="reference internal" href="#ajax">AJAX</a><ul>
<li><a class="reference internal" href="#acquiring-the-token-if-csrf-use-sessions-and-csrf-cookie-httponly-are-false">Acquisition du jeton si <code class="docutils literal notranslate"><span class="pre">CSRF_USE_SESSIONS</span></code> et <code class="docutils literal notranslate"><span class="pre">CSRF_COOKIE_HTTPONLY</span></code> valent <code class="docutils literal notranslate"><span class="pre">False</span></code></a></li>
<li><a class="reference internal" href="#acquiring-the-token-if-csrf-use-sessions-or-csrf-cookie-httponly-is-true">Acquisition du jeton si <code class="docutils literal notranslate"><span class="pre">CSRF_USE_SESSIONS</span></code> ou <code class="docutils literal notranslate"><span class="pre">CSRF_COOKIE_HTTPONLY</span></code> vaut <code class="docutils literal notranslate"><span class="pre">True</span></code></a></li>
<li><a class="reference internal" href="#setting-the-token-on-the-ajax-request">Définition du jeton pour une requête AJAX</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-csrf-in-jinja2-templates">Utilisation de CSRF dans les gabarits Jinja2</a></li>
<li><a class="reference internal" href="#module-django.views.decorators.csrf">La méthode du décorateur</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-requests">Requêtes rejetées</a></li>
<li><a class="reference internal" href="#how-it-works">Fonctionnement</a></li>
<li><a class="reference internal" href="#caching">Mise en cache</a></li>
<li><a class="reference internal" href="#testing">Tests</a></li>
<li><a class="reference internal" href="#limitations">Limitations</a></li>
<li><a class="reference internal" href="#edge-cases">Cas particuliers</a><ul>
<li><a class="reference internal" href="#utilities">Utilitaires</a></li>
<li><a class="reference internal" href="#scenarios">Scénarios</a><ul>
<li><a class="reference internal" href="#csrf-protection-should-be-disabled-for-just-a-few-views">La protection CSRF doit être désactivée pour quelques vues</a></li>
<li><a class="reference internal" href="#csrfviewmiddleware-process-view-not-used">CsrfViewMiddleware.process_view non utilisé</a></li>
<li><a class="reference internal" href="#unprotected-view-needs-the-csrf-token">Une vue non protégée nécessite le jeton CSRF</a></li>
<li><a class="reference internal" href="#view-needs-protection-for-one-path">Une vue a besoin de protection pour un chemin particulier</a></li>
<li><a class="reference internal" href="#page-uses-ajax-without-any-html-form">Une page utilise de l’AJAX sans aucun formulaire HTML</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#contrib-and-reusable-apps">Applications intégrées et applications réutilisables</a></li>
<li><a class="reference internal" href="#settings">Réglages</a></li>
<li><a class="reference internal" href="#frequently-asked-questions">Questions fréquentes</a><ul>
<li><a class="reference internal" href="#is-posting-an-arbitrary-csrf-token-pair-cookie-and-post-data-a-vulnerability">Est-ce que l’envoi d’une paire de jetons CSRF arbitraires (cookie et données POST) est une vulnérabilité&nbsp;?</a></li>
<li><a class="reference internal" href="#is-it-a-problem-that-django-s-csrf-protection-isn-t-linked-to-a-session-by-default">Est-il problématique que la protection CSRF de Django n’est pas liée à une session par défaut&nbsp;?</a></li>
<li><a class="reference internal" href="#why-might-a-user-encounter-a-csrf-validation-failure-after-logging-in">Pourquoi un utilisateur peut-il recevoir une erreur de validation CSRF après s’être connecté&nbsp;?</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Sujet précédent</h4>
  <p class="topless"><a href="contrib/syndication.html"
                        title="Chapitre précédent">L’infrastructure de syndication par flux</a></p>
  <h4>Sujet suivant</h4>
  <p class="topless"><a href="databases.html"
                        title="Chapitre suivant">Bases de données</a></p>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/ref/csrf.txt"
            rel="nofollow">Montrer le code source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Recherche rapide</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">oct. 29, 2020</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="contrib/syndication.html" title="L’infrastructure de syndication par flux">previous</a>
     |
    <a href="index.html" title="Référence de l’API" accesskey="U">up</a>
   |
    <a href="databases.html" title="Bases de données">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>