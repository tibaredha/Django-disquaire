
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Applications &#8212; Documentation Django 3.1.3.dev</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="next" title="Infrastructure de contrôle système" href="checks.html" />
    <link rel="prev" title="Référence de l’API" href="index.html" />



 
<script src="../templatebuiltins.js"></script>
<script>
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);</script>

  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Documentation Django 3.1.3.dev</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">Home</a>  |
        <a title="Table of contents" href="../contents.html">Table of contents</a>  |
        <a title="Global index" href="../genindex.html">Index</a>  |
        <a title="Module index" href="../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="index.html" title="Référence de l’API">previous</a>
     |
    <a href="index.html" title="Référence de l’API" accesskey="U">up</a>
   |
    <a href="checks.html" title="Infrastructure de contrôle système">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="ref-applications">
            
  <div class="section" id="s-module-django.apps">
<span id="s-applications"></span><span id="module-django.apps"></span><span id="applications"></span><h1>Applications<a class="headerlink" href="#module-django.apps" title="Lien permanent vers ce titre">¶</a></h1>
<p>Django contient un registre des applications installées qui stocke la configuration et fournit l’introspection. Il maintient également une liste des <a class="reference internal" href="../topics/db/models.html"><span class="doc">modèles</span></a> disponibles.</p>
<p>Ce registre est appelé <a class="reference internal" href="#django.apps.apps" title="django.apps.apps"><code class="xref py py-attr docutils literal notranslate"><span class="pre">apps</span></code></a> et est disponible dans <a class="reference internal" href="#module-django.apps" title="django.apps"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.apps</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.apps</span> <span class="k">import</span> <span class="n">apps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apps</span><span class="o">.</span><span class="n">get_app_config</span><span class="p">(</span><span class="s1">&#39;admin&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">verbose_name</span>
<span class="go">&#39;Administration&#39;</span>
</pre></div>
</div>
<div class="section" id="s-projects-and-applications">
<span id="projects-and-applications"></span><h2>Projets et applications<a class="headerlink" href="#projects-and-applications" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le terme <strong>projet</strong> décrit une application Web Django. Le paquet Python du projet est définit principalement par un module de réglages <code class="docutils literal notranslate"><span class="pre">settings</span></code>, mais il contient généralement d’autres choses. Par exemple, lorsque vous exécutez <code class="docutils literal notranslate"><span class="pre">django-admin</span> <span class="pre">startproject</span> <span class="pre">monsite</span></code>, vous obtenez un répertoire de projet <code class="docutils literal notranslate"><span class="pre">monsite</span></code> contenant un paquet Python <code class="docutils literal notranslate"><span class="pre">monsite</span></code> avec les fichiers <code class="docutils literal notranslate"><span class="pre">settings.py</span></code>, <code class="docutils literal notranslate"><span class="pre">urls.py</span></code>, <code class="docutils literal notranslate"><span class="pre">asgi.py</span></code> et <code class="docutils literal notranslate"><span class="pre">wsgi.py</span></code>. Le paquet de projet est souvent étendu par l’ajout de choses comme des instantanés, des fichiers CSS et des gabarits qui ne sont pas liés à une application particulière.</p>
<p>Un <strong>répertoire racine de projet</strong> (celui qui contient <code class="docutils literal notranslate"><span class="pre">manage.py</span></code>) est généralement un conteneur pour toutes les applications d’un projet qui ne sont pas installées séparément.</p>
<p>Le terme <strong>application</strong> décrit un paquet Python qui fournit un certain ensemble de fonctionnalités. Les applications <a class="reference internal" href="../intro/reusable-apps.html"><span class="doc">peuvent être réutilisées</span></a> dans différents projets.</p>
<p>Les applications comprennent une combinaison de modèles, vues, gabarits, balises de gabarits, fichiers statiques, URL, intergiciels, etc. Elles sont généralement liées à des projets via le réglage <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> et éventuellement avec d’autres mécanismes tels que les configurations d’URL, le réglage <a class="reference internal" href="settings.html#std:setting-MIDDLEWARE"><code class="xref std std-setting docutils literal notranslate"><span class="pre">MIDDLEWARE</span></code></a> ou l’héritage de gabarit.</p>
<p>Il est important de comprendre qu’une application Django est un ensemble de code qui interagit avec les différentes parties du système. Il n’existe pas d’objet <code class="docutils literal notranslate"><span class="pre">Application</span></code> en tant que tel. Cependant, il y a quelques endroits où Django a besoin d’interagir avec les applications installées, principalement pour la configuration et aussi l’introspection. C’est pourquoi le registre des applications maintient des métadonnées dans une instance de <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> pour chaque application installée.</p>
<p>Il n’y a pas restriction au fait qu’un paquet de projet ne puisse pas aussi être considéré comme une application et qu’il contienne des modèles, etc. (ce qui demanderait de l’ajouter dans la liste <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a>).</p>
</div>
<div class="section" id="s-configuring-applications">
<span id="s-configuring-applications-ref"></span><span id="configuring-applications"></span><span id="configuring-applications-ref"></span><h2>Configuration des applications<a class="headerlink" href="#configuring-applications" title="Lien permanent vers ce titre">¶</a></h2>
<p>Pour configurer une application, héritez de <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> et placez le chemin de cette sous-classe avec la syntaxe pointée dans <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a>.</p>
<p>Lorsque <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> contient le chemin vers un module d’application avec la syntaxe pointée, Django recherche une variable <code class="docutils literal notranslate"><span class="pre">default_app_config</span></code> dans ce module.</p>
<p>Si elle est définie, il s’agit du chemin en syntaxe pointée vers la sous-classe de <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> pour cette application.</p>
<p>S’il n’y a pas de <code class="docutils literal notranslate"><span class="pre">default_app_config</span></code>, Django utilise la classe de base <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">default_app_config</span></code> permet aux applications créées avant Django 1.7 telles que  <code class="docutils literal notranslate"><span class="pre">django.contrib.admin</span></code> de faire la transition vers la fonctionnalité <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> sans exiger des utilisateurs qu’ils mettent à jour leur réglage <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a>.</p>
<p>Les nouvelles applications devraient éviter <code class="docutils literal notranslate"><span class="pre">default_app_config</span></code>. Elles devraient plutôt exiger le chemin pointé vers la sous-classe <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> appropriée de manière explicite dans le réglage <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a>.</p>
<div class="section" id="s-for-application-authors">
<span id="for-application-authors"></span><h3>Pour les auteurs d’applications<a class="headerlink" href="#for-application-authors" title="Lien permanent vers ce titre">¶</a></h3>
<p>Si vous créez une application réutilisable appelée «&nbsp;Rock “n” roll&nbsp;», voici comment vous pourriez définir un nom approprié pour l’interface d’administration&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># rock_n_roll/apps.py</span>

<span class="kn">from</span> <span class="nn">django.apps</span> <span class="k">import</span> <span class="n">AppConfig</span>

<span class="k">class</span> <span class="nc">RockNRollConfig</span><span class="p">(</span><span class="n">AppConfig</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;rock_n_roll&#39;</span>
    <span class="n">verbose_name</span> <span class="o">=</span> <span class="s2">&quot;Rock ’n’ roll&quot;</span>
</pre></div>
</div>
<p>Vous pouvez faire en sorte que votre application charge cette sous-classe de <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> par défaut comme cela&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># rock_n_roll/__init__.py</span>

<span class="n">default_app_config</span> <span class="o">=</span> <span class="s1">&#39;rock_n_roll.apps.RockNRollConfig&#39;</span>
</pre></div>
</div>
<p>Cela entraîne l’utilisation de <code class="docutils literal notranslate"><span class="pre">RockNRollConfig</span></code> lorsque <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> contient seulement <code class="docutils literal notranslate"><span class="pre">'rock_n_roll'</span></code>. Cela permet d’utiliser les fonctionnalités de <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> sans exiger des utilisateurs qu’ils mettent à jour leur réglage <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a>. En dehors de ce cas d’utilisation, il est préférable d’éviter l’utilisation de <code class="docutils literal notranslate"><span class="pre">default_app_config</span></code> mais de plutôt indiquer la classe de configuration d’application dans <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> comme expliqué ci-après.</p>
<p>Vous pouvez aussi dire à vos utilisateurs de mettre <code class="docutils literal notranslate"><span class="pre">'rock_n_roll.apps.RockNRollConfig'</span></code> dans leur réglage <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a>. Vous pouvez même fournir plusieurs sous-classes de <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> différentes avec des comportements différents et permettre aux utilisateurs d’en choisir une via leur réglage <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a>.</p>
<p>La convention recommandée est de mettre la classe de configuration dans un sous-module de l’application nommé <code class="docutils literal notranslate"><span class="pre">apps</span></code>. Cependant, ce n’est pas requis par Django.</p>
<p>Vous devez inclure l’attribut <a class="reference internal" href="#django.apps.AppConfig.name" title="django.apps.AppConfig.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> pour que Django puisse déterminer à quelle application cette configuration s’applique. Vous pouvez définir n’importe quel attribut documenté dans la référence de l’API de <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Si votre code importe le registre des applications dans le fichier <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> d’une application, le nom <code class="docutils literal notranslate"><span class="pre">apps</span></code> entrera en conflit avec le sous-module <code class="docutils literal notranslate"><span class="pre">apps</span></code>. La meilleure approche consiste à déplacer ce code vers un sous-module et de l’importer. Une solution de contournement consiste à importer le registre sous un nom différent&nbsp;:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.apps</span> <span class="k">import</span> <span class="n">apps</span> <span class="k">as</span> <span class="n">django_apps</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-for-application-users">
<span id="for-application-users"></span><h3>Pour les utilisateurs d’applications<a class="headerlink" href="#for-application-users" title="Lien permanent vers ce titre">¶</a></h3>
<p>Si vous utilisez «&nbsp;Rock “n” roll&nbsp;» dans un projet appelé <code class="docutils literal notranslate"><span class="pre">anthology</span></code>, mais que vous souhaitez plutôt qu’il apparaisse comme «&nbsp;Jazz Manouche&nbsp;», vous pouvez fournir votre propre configuration&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># anthology/apps.py</span>

<span class="kn">from</span> <span class="nn">rock_n_roll.apps</span> <span class="k">import</span> <span class="n">RockNRollConfig</span>

<span class="k">class</span> <span class="nc">JazzManoucheConfig</span><span class="p">(</span><span class="n">RockNRollConfig</span><span class="p">):</span>
    <span class="n">verbose_name</span> <span class="o">=</span> <span class="s2">&quot;Jazz Manouche&quot;</span>

<span class="c1"># anthology/settings.py</span>

<span class="n">INSTALLED_APPS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;anthology.apps.JazzManoucheConfig&#39;</span><span class="p">,</span>
    <span class="c1"># ...</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Encore une fois, la définition de classes de configuration spécifiques au projet dans un sous-module appelé <code class="docutils literal notranslate"><span class="pre">apps</span></code> est une convention, pas une obligation.</p>
</div>
</div>
<div class="section" id="s-application-configuration">
<span id="application-configuration"></span><h2>Configuration d’applications<a class="headerlink" href="#application-configuration" title="Lien permanent vers ce titre">¶</a></h2>
<dl class="class">
<dt id="django.apps.AppConfig">
<em class="property">class </em><code class="descname">AppConfig</code><a class="reference internal" href="../_modules/django/apps/config.html#AppConfig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#django.apps.AppConfig" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Les objets de configuration d’application stockent les métadonnées d’une application. Certains attributs peuvent être configurés dans des sous-classes de <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a>. D’autres sont définis par Django et sont en lecture seule.</p>
</dd></dl>

<div class="section" id="s-configurable-attributes">
<span id="configurable-attributes"></span><h3>Attributs configurables<a class="headerlink" href="#configurable-attributes" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="attribute">
<dt id="django.apps.AppConfig.name">
<code class="descclassname">AppConfig.</code><code class="descname">name</code><a class="headerlink" href="#django.apps.AppConfig.name" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Chemin Python complet vers l’application, par ex. <code class="docutils literal notranslate"><span class="pre">'django.contrib.admin'</span></code>.</p>
<p>Cet attribut détermine à quelle application la configuration s’applique. Il doit être défini dans toutes les sous-classes de <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a>.</p>
<p>Il doit être unique dans le contexte d’un même projet Django.</p>
</dd></dl>

<dl class="attribute">
<dt id="django.apps.AppConfig.label">
<code class="descclassname">AppConfig.</code><code class="descname">label</code><a class="headerlink" href="#django.apps.AppConfig.label" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Nom court de l’application, par ex. <code class="docutils literal notranslate"><span class="pre">'admin'</span></code></p>
<p>Cet attribut permet de ré-étiqueter une application lorsque deux applications ont des étiquettes incompatibles. Par défaut, <code class="docutils literal notranslate"><span class="pre">label</span></code> est le dernier élément de <code class="docutils literal notranslate"><span class="pre">name</span></code>. Il doit être un identifiant Python valide.</p>
<p>Il doit être unique dans le contexte d’un même projet Django.</p>
</dd></dl>

<dl class="attribute">
<dt id="django.apps.AppConfig.verbose_name">
<code class="descclassname">AppConfig.</code><code class="descname">verbose_name</code><a class="headerlink" href="#django.apps.AppConfig.verbose_name" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Nom convivial de l’application, par ex. «&nbsp;Administration&nbsp;».</p>
<p>Par défaut, cet attribut est équivalent à <code class="docutils literal notranslate"><span class="pre">label.title()</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="django.apps.AppConfig.path">
<code class="descclassname">AppConfig.</code><code class="descname">path</code><a class="headerlink" href="#django.apps.AppConfig.path" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Chemin du système de fichiers vers le répertoire de l’application, par ex. <code class="docutils literal notranslate"><span class="pre">'/usr/lib/pythonX.Y/dist-packages/django/contrib/admin'</span></code>.</p>
<p>Dans la plupart des cas, Django peut automatiquement détecter et définir cet attribut, mais vous pouvez également fournir une dérogation explicite comme attribut de classe sur la sous-classe de <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a>. Dans certains cas, c’est une nécessité&nbsp;; par exemple, si le paquet de l’application est un <a class="reference internal" href="#namespace-package">paquet avec espace de noms</a> comprenant plusieurs chemins.</p>
</dd></dl>

</div>
<div class="section" id="s-read-only-attributes">
<span id="read-only-attributes"></span><h3>Attributs en lecture seule<a class="headerlink" href="#read-only-attributes" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="attribute">
<dt id="django.apps.AppConfig.module">
<code class="descclassname">AppConfig.</code><code class="descname">module</code><a class="headerlink" href="#django.apps.AppConfig.module" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Module racine de l’application, par ex. <code class="docutils literal notranslate"><span class="pre">&lt;module</span> <span class="pre">'django.contrib.admin'</span> <span class="pre">from</span> <span class="pre">'django/contrib/admin/__init__.py'&gt;</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="django.apps.AppConfig.models_module">
<code class="descclassname">AppConfig.</code><code class="descname">models_module</code><a class="headerlink" href="#django.apps.AppConfig.models_module" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Module contenant les modèles, par ex. <code class="docutils literal notranslate"><span class="pre">&lt;module</span> <span class="pre">'django.contrib.admin.models'</span> <span class="pre">from</span> <span class="pre">'django/contrib/admin/models.py'&gt;</span></code>.</p>
<p>Il peut valoir <code class="docutils literal notranslate"><span class="pre">None</span></code> si l’application ne contient pas de module <code class="docutils literal notranslate"><span class="pre">models</span></code>. Notez que les signaux relatifs à la base de données tels que <a class="reference internal" href="signals.html#django.db.models.signals.pre_migrate" title="django.db.models.signals.pre_migrate"><code class="xref py py-data docutils literal notranslate"><span class="pre">pre_migrate</span></code></a> et <a class="reference internal" href="signals.html#django.db.models.signals.post_migrate" title="django.db.models.signals.post_migrate"><code class="xref py py-data docutils literal notranslate"><span class="pre">post_migrate</span></code></a> ne sont émis que pour les applications qui ont un module <code class="docutils literal notranslate"><span class="pre">models</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="s-methods">
<span id="methods"></span><h3>Méthodes<a class="headerlink" href="#methods" title="Lien permanent vers ce titre">¶</a></h3>
<dl class="method">
<dt id="django.apps.AppConfig.get_models">
<code class="descclassname">AppConfig.</code><code class="descname">get_models</code>()<a class="reference internal" href="../_modules/django/apps/config.html#AppConfig.get_models"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#django.apps.AppConfig.get_models" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un objet itérable de classes <a class="reference internal" href="models/instances.html#django.db.models.Model" title="django.db.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> pour cette application.</p>
<p>Nécessite que le registre des applications soit complètement défini.</p>
</dd></dl>

<dl class="method">
<dt id="django.apps.AppConfig.get_model">
<code class="descclassname">AppConfig.</code><code class="descname">get_model</code>(<em>model_name</em>, <em>require_ready=True</em>)<a class="reference internal" href="../_modules/django/apps/config.html#AppConfig.get_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#django.apps.AppConfig.get_model" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie la classe <a class="reference internal" href="models/instances.html#django.db.models.Model" title="django.db.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> ayant le nom <code class="docutils literal notranslate"><span class="pre">model_name</span></code> donné. <code class="docutils literal notranslate"><span class="pre">model_name</span></code> est insensible à la casse.</p>
<p>Génère <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#LookupError" title="(disponible dans Python v3.9)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> si aucun modèle de ce nom n’existe dans cette application.</p>
<p>Nécessite que le registre des applications soit complètement défini, sauf dans le cas où le paramètre <code class="docutils literal notranslate"><span class="pre">require_ready</span></code> est <code class="docutils literal notranslate"><span class="pre">False</span></code>. <code class="docutils literal notranslate"><span class="pre">require_ready</span></code> a le même comportement que pour <a class="reference internal" href="#django.apps.apps.get_model" title="django.apps.apps.get_model"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apps.get_model()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="django.apps.AppConfig.ready">
<code class="descclassname">AppConfig.</code><code class="descname">ready</code>()<a class="reference internal" href="../_modules/django/apps/config.html#AppConfig.ready"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#django.apps.AppConfig.ready" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Les sous-classes peuvent étendre cette méthode pour effectuer des tâches d’initialisation telles que l’enregistrement de signaux. Elle est appelée dès que le registre est entièrement peuplé.</p>
<p>Même s’il n’est pas possible d’importer des modèles au niveau des modules où les classes <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> sont définies, il est possible de les importer dans <code class="docutils literal notranslate"><span class="pre">ready()</span></code>, en utilisant soit une instruction <code class="docutils literal notranslate"><span class="pre">import</span></code> ou <a class="reference internal" href="#django.apps.AppConfig.get_model" title="django.apps.AppConfig.get_model"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_model()</span></code></a>.</p>
<p>Si vous inscrivez des <a class="reference internal" href="signals.html#module-django.db.models.signals" title="django.db.models.signals: Signals sent by the model system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signaux</span> <span class="pre">de</span> <span class="pre">modèle</span></code></a>, vous pouvez faire référence à l’expéditeur par son étiquette textuelle au lieu d’utiliser la classe de modèle en elle-même.</p>
<p>Exemple&nbsp;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.apps</span> <span class="k">import</span> <span class="n">AppConfig</span>
<span class="kn">from</span> <span class="nn">django.db.models.signals</span> <span class="k">import</span> <span class="n">pre_save</span>


<span class="k">class</span> <span class="nc">RockNRollConfig</span><span class="p">(</span><span class="n">AppConfig</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span> <span class="nf">ready</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># importing model classes</span>
        <span class="kn">from</span> <span class="nn">.models</span> <span class="k">import</span> <span class="n">MyModel</span>  <span class="c1"># or...</span>
        <span class="n">MyModel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model</span><span class="p">(</span><span class="s1">&#39;MyModel&#39;</span><span class="p">)</span>

        <span class="c1"># registering signals with the model&#39;s string label</span>
        <span class="n">pre_save</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">sender</span><span class="o">=</span><span class="s1">&#39;app_label.MyModel&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Avertissement</p>
<p class="last">Bien que vous puissiez accéder aux classes de modèles comme expliqué ci-dessus, évitez d’interagir avec la base de données dans l’implémentation de <a class="reference internal" href="#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ready()</span></code></a>. Ceci inclut les méthodes de modèles qui exécutent des requêtes (<a class="reference internal" href="models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a>, <a class="reference internal" href="models/instances.html#django.db.models.Model.delete" title="django.db.models.Model.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a>, les méthodes de gestionnaires de modèles, etc.), ainsi que les requêtes SQL brutes via <code class="docutils literal notranslate"><span class="pre">django.db.connection</span></code>. La méthode <a class="reference internal" href="#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ready()</span></code></a> s’exécute lors du démarrage de chaque commande de gestion. Par exemple, bien que la configuration de la base de données de test soit séparée des réglages de production, <code class="docutils literal notranslate"><span class="pre">manage.py</span> <span class="pre">test</span></code> pourrait malgré tout exécuter des requêtes sur votre base de données de <strong>production</strong>&nbsp;!</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Dans le processus d’initialisation normal, la méthode <code class="docutils literal notranslate"><span class="pre">ready</span></code> est appelée une seule fois par Django. Mais dans certains cas limites, en particulier dans les tests qui manipulent les applications installées, <code class="docutils literal notranslate"><span class="pre">ready</span></code> pourrait être appelée plus d’une fois. Dans ce cas, soit écrivez des méthodes idempotentes, soit placez un drapeau sur vos classes <code class="docutils literal notranslate"><span class="pre">AppConfig</span></code> pour empêcher de ré-exécuter le code qui ne devrait être exécuté qu’une seule fois.</p>
</div>
</dd></dl>

</div>
<div class="section" id="s-namespace-packages-as-apps">
<span id="s-namespace-package"></span><span id="namespace-packages-as-apps"></span><span id="namespace-package"></span><h3>Paquets avec espace de noms en tant qu’applications<a class="headerlink" href="#namespace-packages-as-apps" title="Lien permanent vers ce titre">¶</a></h3>
<p>Les paquets Python sans la présence d’un fichier <code class="docutils literal notranslate"><span class="pre">__init</span> <span class="pre">__.py</span></code> sont appelés «&nbsp;paquets avec espace de noms&nbsp;» (namespace packages) et peuvent être dispersés dans plusieurs répertoires et à différents endroits de <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> (voir <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a>).</p>
<p>Les applications Django nécessitent un chemin de base unique du système de fichiers où Django (selon la configuration) recherche les gabarits, les fichiers statiques, etc. Ainsi, les paquets avec espace de noms ne peuvent être des applications Django que si l’une des conditions suivantes est vraie&nbsp;:</p>
<ol class="arabic simple">
<li>Le paquet avec espace de noms n’a en fait qu’un seul emplacement (c’est-à-dire qu’il n’est pas dispersé sur plus d’un répertoire).</li>
<li>La classe <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> utilisée pour configurer l’application possède un attribut de classe <a class="reference internal" href="#django.apps.AppConfig.path" title="django.apps.AppConfig.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> qui correspond au chemin de répertoire absolu que Django utilise comme chemin de base unique pour l’application.</li>
</ol>
<p>Si aucune de ces conditions n’est remplie, Django génère une exception <a class="reference internal" href="exceptions.html#django.core.exceptions.ImproperlyConfigured" title="django.core.exceptions.ImproperlyConfigured"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImproperlyConfigured</span></code></a>.</p>
</div>
</div>
<div class="section" id="s-application-registry">
<span id="application-registry"></span><h2>Registre d’applications<a class="headerlink" href="#application-registry" title="Lien permanent vers ce titre">¶</a></h2>
<dl class="data">
<dt id="django.apps.apps">
<code class="descname">apps</code><a class="headerlink" href="#django.apps.apps" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Le registre d’applications fournit l’API publique suivante. Les méthodes qui ne sont pas énumérées ci-dessous sont considérées comme privées et peuvent changer sans préavis.</p>
</dd></dl>

<dl class="attribute">
<dt id="django.apps.apps.ready">
<code class="descclassname">apps.</code><code class="descname">ready</code><a class="headerlink" href="#django.apps.apps.ready" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Attribut booléen défini à <code class="docutils literal notranslate"><span class="pre">True</span></code> après que le registre a été entièrement peuplé et que toutes les méthodes <a class="reference internal" href="#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AppConfig.ready()</span></code></a> ont été appelées.</p>
</dd></dl>

<dl class="method">
<dt id="django.apps.apps.get_app_configs">
<code class="descclassname">apps.</code><code class="descname">get_app_configs</code>()<a class="headerlink" href="#django.apps.apps.get_app_configs" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie un objet itérable d’instances de <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="django.apps.apps.get_app_config">
<code class="descclassname">apps.</code><code class="descname">get_app_config</code>(<em>app_label</em>)<a class="headerlink" href="#django.apps.apps.get_app_config" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie une instance <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> de l’application correspondant à <code class="docutils literal notranslate"><span class="pre">app_label</span></code>. Génère <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#LookupError" title="(disponible dans Python v3.9)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> si une telle application n’existe pas.</p>
</dd></dl>

<dl class="method">
<dt id="django.apps.apps.is_installed">
<code class="descclassname">apps.</code><code class="descname">is_installed</code>(<em>app_name</em>)<a class="headerlink" href="#django.apps.apps.is_installed" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Vérifie si une application avec le nom donné existe dans le registre. <code class="docutils literal notranslate"><span class="pre">app_name</span></code> est le nom complet de l’application, par ex. <code class="docutils literal notranslate"><span class="pre">'django.contrib.admin'</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="django.apps.apps.get_model">
<code class="descclassname">apps.</code><code class="descname">get_model</code>(<em>app_label</em>, <em>model_name</em>, <em>require_ready=True</em>)<a class="headerlink" href="#django.apps.apps.get_model" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Renvoie la classe <a class="reference internal" href="models/instances.html#django.db.models.Model" title="django.db.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> correspondant aux paramètres <code class="docutils literal notranslate"><span class="pre">app_label</span></code> et <code class="docutils literal notranslate"><span class="pre">model_name</span></code>. Cette méthode accepte aussi en raccourci un paramètre unique sous la forme <code class="docutils literal notranslate"><span class="pre">app_label.model_name</span></code>. <code class="docutils literal notranslate"><span class="pre">model_name</span></code> est insensible à la casse.</p>
<p>Génère <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#LookupError" title="(disponible dans Python v3.9)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> si aucune application ou modèle correspondant n’existe. Génère <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(disponible dans Python v3.9)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> lorsque un paramètre unique est fourni sans contenir exactement un seul point.</p>
<p>Nécessite que le registre des applications soit complètement défini, sauf dans le cas où le paramètre <code class="docutils literal notranslate"><span class="pre">require_ready</span></code> est <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>La définition de <code class="docutils literal notranslate"><span class="pre">require_ready</span></code> à <code class="docutils literal notranslate"><span class="pre">False</span></code> permet de consulter des modèles <a class="reference internal" href="#app-loading-process"><span class="std std-ref">pendant que le registre des applications est en cours de remplissage</span></a>, particulièrement dans la seconde phase où les modèles sont importés. <code class="docutils literal notranslate"><span class="pre">get_model()</span></code> a donc le même effet que l’importation du modèle. Le principal cas d’utilisation concerne la configuration de classes de modèles en fonction de réglages, tels que <a class="reference internal" href="settings.html#std:setting-AUTH_USER_MODEL"><code class="xref std std-setting docutils literal notranslate"><span class="pre">AUTH_USER_MODEL</span></code></a>.</p>
<p>Lorsque <code class="docutils literal notranslate"><span class="pre">require_ready</span></code> vaut <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">get_model()</span></code> renvoie une classe de modèle qui peut ne pas être complètement fonctionnelle (par exemple, l’accès aux relations inversées peut être manquant) en attendant que le registre des applications soit complètement rempli. Pour cette raison, il est préférable de laisser <code class="docutils literal notranslate"><span class="pre">require_ready</span></code> à sa valeur par défaut <code class="docutils literal notranslate"><span class="pre">True</span></code> autant que possible.</p>
</dd></dl>

</div>
<div class="section" id="s-initialization-process">
<span id="s-app-loading-process"></span><span id="initialization-process"></span><span id="app-loading-process"></span><h2>Processus d’initialisation<a class="headerlink" href="#initialization-process" title="Lien permanent vers ce titre">¶</a></h2>
<div class="section" id="s-how-applications-are-loaded">
<span id="how-applications-are-loaded"></span><h3>Chargement des applications<a class="headerlink" href="#how-applications-are-loaded" title="Lien permanent vers ce titre">¶</a></h3>
<p>Lorsque Django démarre, <a class="reference internal" href="#django.setup" title="django.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.setup()</span></code></a> est responsable de peupler le registre des applications.</p>
<dl class="function">
<dt id="django.setup">
<code class="descname">setup</code>(<em>set_prefix=True</em>)<a class="reference internal" href="../_modules/django.html#setup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#django.setup" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Configure Django en&nbsp;:</p>
<ul class="simple">
<li>chargeant les réglages&nbsp;;</li>
<li>configurant la journalisation&nbsp;;</li>
<li>Si <code class="docutils literal notranslate"><span class="pre">set_prefix</span></code> vaut <code class="docutils literal notranslate"><span class="pre">True</span></code>, définissant le préfixe de script de résolution d’URL à <a class="reference internal" href="settings.html#std:setting-FORCE_SCRIPT_NAME"><code class="xref std std-setting docutils literal notranslate"><span class="pre">FORCE_SCRIPT_NAME</span></code></a> s’il est défini ou sinon à <code class="docutils literal notranslate"><span class="pre">/</span></code>.</li>
<li>initialisant le registre d’applications.</li>
</ul>
<p>Cette fonction est appelée automatiquement&nbsp;:</p>
<ul class="simple">
<li>lors de l’exécution d’un serveur HTTP via le support WSGI de Django&nbsp;;</li>
<li>lors de l’appel d’une commande de gestion.</li>
</ul>
<p>Elle doit être appelée explicitement dans d’autres cas, comme par exemple dans les scripts Python ordinaires.</p>
</dd></dl>

<p>Le registre d’applications est initialisé en trois étapes. À chaque étape, Django traite toutes les applications dans l’ordre de <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a>.</p>
<ol class="arabic">
<li><p class="first">Tout d’abord, Django importe chaque élément de <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a>.</p>
<p>S’il s’agit d’une classe de configuration de l’application, Django importe le paquet racine de l’application, défini par son attribut <a class="reference internal" href="#django.apps.AppConfig.name" title="django.apps.AppConfig.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a>. S’il s’agit d’un paquet Python, Django crée une configuration d’application par défaut.</p>
<p><em>À ce stade, votre code ne devrait pas importer de modèles !</em></p>
<p>En d’autres termes, les paquets racines de vos applications et les modules qui définissent vos classes de configuration d’application ne devraient pas importer de modèles, même indirectement.</p>
<p>Strictement parlant, Django permet d’importer des modèles une fois que leur configuration d’application est chargée. Toutefois, afin d’éviter toute contrainte inutile sur l’ordre dans <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a>, il est fortement recommandé de ne pas importer de modèles à ce stade.</p>
<p>Une fois cette étape terminée, les API qui exploitent les configurations d’application telles que <a class="reference internal" href="#django.apps.apps.get_app_config" title="django.apps.apps.get_app_config"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_app_config()</span></code></a> deviennent utilisables.</p>
</li>
<li><p class="first">Puis Django tente d’importer le sous-module <code class="docutils literal notranslate"><span class="pre">models</span></code> de chaque application, s’il en existe un.</p>
<p>Vous devez définir ou importer tous les modèles dans les fichiers <code class="docutils literal notranslate"><span class="pre">models.py</span></code> ou <code class="docutils literal notranslate"><span class="pre">models/__init__.py</span></code> de votre application. Autrement, le registre des applications pouvant ne pas être entièrement peuplé à ce point, cela pourrait provoquer un dysfonctionnement de l’ORM.</p>
<p>Une fois cette étape terminée, les API qui agissent sur des modèles telles que <a class="reference internal" href="#django.apps.apps.get_model" title="django.apps.apps.get_model"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_model()</span></code></a> deviennent utilisables.</p>
</li>
<li><p class="first">Enfin, Django exécute la méthode <a class="reference internal" href="#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ready()</span></code></a> de chaque configuration d’application.</p>
</li>
</ol>
</div>
<div class="section" id="s-troubleshooting">
<span id="s-applications-troubleshooting"></span><span id="troubleshooting"></span><span id="applications-troubleshooting"></span><h3>Dépannage<a class="headerlink" href="#troubleshooting" title="Lien permanent vers ce titre">¶</a></h3>
<p>Voici quelques problèmes courants que vous pouvez rencontrer lors de l’initialisation&nbsp;:</p>
<ul>
<li><p class="first"><a class="reference internal" href="exceptions.html#django.core.exceptions.AppRegistryNotReady" title="django.core.exceptions.AppRegistryNotReady"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppRegistryNotReady</span></code></a>: cela se produit lorsque l’importation d’une configuration d’application ou d’un module de modèles exécute du code qui dépend du registre d’applications.</p>
<p>Par exemple, <a class="reference internal" href="utils.html#django.utils.translation.gettext" title="django.utils.translation.gettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">gettext()</span></code></a> utilise le registre d’applications pour rechercher des catalogues de traduction dans les applications. Pour traduire au moment de l’importation, vous devez utiliser <a class="reference internal" href="utils.html#django.utils.translation.gettext_lazy" title="django.utils.translation.gettext_lazy"><code class="xref py py-func docutils literal notranslate"><span class="pre">gettext_lazy()</span></code></a> à la place (l’utilisation de <a class="reference internal" href="utils.html#django.utils.translation.gettext" title="django.utils.translation.gettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">gettext()</span></code></a> serait une erreur, parce que la traduction s’effectuerait au moment de l’importation plutôt qu’à chaque requête en fonction de la langue active).</p>
<p>L’exécution de requêtes en base de données avec l’ORM au moment de l’importation dans les modules de modèles déclenche également cette exception. L’ORM ne peut pas fonctionner correctement avant que tous les modèles ne soient disponibles.</p>
<p>Cette exception se produit également si vous oubliez d’appeler <a class="reference internal" href="#django.setup" title="django.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.setup()</span></code></a> dans un script Python autonome.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">cannot</span> <span class="pre">import</span> <span class="pre">name</span> <span class="pre">...</span></code> Cela se produit si la séquence d’importation se trouve être une boucle.</p>
<p>Pour éliminer de tels problèmes, vous devez réduire les dépendances entre vos modules de modèles et réaliser le moins de travail possible au moment de l’importation. Pour éviter d’exécuter du code au moment de l’importation, vous pouvez le déplacer dans une fonction et mettre en cache ses résultats. Le code sera exécuté la première fois que vous aurez besoin de ses résultats. Ce concept est connu sous le nom d”«&nbsp;évaluation différée&nbsp;».</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">django.contrib.admin</span></code> effectue automatiquement la découverte des modules <code class="docutils literal notranslate"><span class="pre">admin</span></code> dans les applications installées. Pour l’en empêcher, modifiez le réglage <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> pour qu’il contienne <code class="docutils literal notranslate"><span class="pre">'django.contrib.admin.apps.SimpleAdminConfig'</span></code> au lieu de <code class="docutils literal notranslate"><span class="pre">'django.contrib.admin'</span></code>.</p>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Applications</a><ul>
<li><a class="reference internal" href="#projects-and-applications">Projets et applications</a></li>
<li><a class="reference internal" href="#configuring-applications">Configuration des applications</a><ul>
<li><a class="reference internal" href="#for-application-authors">Pour les auteurs d’applications</a></li>
<li><a class="reference internal" href="#for-application-users">Pour les utilisateurs d’applications</a></li>
</ul>
</li>
<li><a class="reference internal" href="#application-configuration">Configuration d’applications</a><ul>
<li><a class="reference internal" href="#configurable-attributes">Attributs configurables</a></li>
<li><a class="reference internal" href="#read-only-attributes">Attributs en lecture seule</a></li>
<li><a class="reference internal" href="#methods">Méthodes</a></li>
<li><a class="reference internal" href="#namespace-packages-as-apps">Paquets avec espace de noms en tant qu’applications</a></li>
</ul>
</li>
<li><a class="reference internal" href="#application-registry">Registre d’applications</a></li>
<li><a class="reference internal" href="#initialization-process">Processus d’initialisation</a><ul>
<li><a class="reference internal" href="#how-applications-are-loaded">Chargement des applications</a></li>
<li><a class="reference internal" href="#troubleshooting">Dépannage</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Sujet précédent</h4>
  <p class="topless"><a href="index.html"
                        title="Chapitre précédent">Référence de l’API</a></p>
  <h4>Sujet suivant</h4>
  <p class="topless"><a href="checks.html"
                        title="Chapitre suivant">Infrastructure de contrôle système</a></p>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/ref/applications.txt"
            rel="nofollow">Montrer le code source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Recherche rapide</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">oct. 29, 2020</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="index.html" title="Référence de l’API">previous</a>
     |
    <a href="index.html" title="Référence de l’API" accesskey="U">up</a>
   |
    <a href="checks.html" title="Infrastructure de contrôle système">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>